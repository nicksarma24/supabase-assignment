{"version":3,"file":"resemble.modern.js","sources":["../src/context.ts","../src/v2/util.ts","../src/v2/projects.ts","../src/v2/StreamDecoder.ts","../src/v2/clips.ts","../src/v2/recordings.ts","../src/v2/voices.ts","../src/v2/batch.ts","../src/v2/phonemes.ts","../src/v2/termSubstitutions.ts","../src/resemble.ts"],"sourcesContent":["let apiKey: string | undefined = ''\nlet baseUrl: string | undefined = 'https://app.resemble.ai/api/'\nlet synthesisServerUrl: string | undefined = ''\n\nconst synthesisServerHeaders: Record<string, string> = {\n  'Content-Type': 'application/json',\n  'x-access-token': apiKey,\n}\n\nconst headers: Record<string, string> = {\n  'Content-Type': 'application/json',\n  Authorization: `Token token=${apiKey}`,\n}\n\nexport const context = {\n  headers: () => headers,\n  synthesisServerHeaders: () => synthesisServerHeaders,\n\n  setBaseUrl: (url: string) => {\n    baseUrl = url\n\n    if (!url.endsWith('/')) {\n      baseUrl += '/'\n    }\n  },\n\n  setApiKey: (key: string) => {\n    apiKey = key\n    headers['Authorization'] = `Token token=${key}`\n    synthesisServerHeaders['x-access-token'] = key\n  },\n\n  setSynthesisUrl: (url: string) => {\n    synthesisServerUrl = url\n\n    if (!url.endsWith('/')) {\n      synthesisServerUrl += '/'\n    }\n  },\n\n  endpoint: (version: string, endpoint: string): string => {\n    let ending = endpoint.startsWith('/') ? endpoint.substring(1) : endpoint\n    return `${baseUrl}${version}/${ending}`\n  },\n\n  synServerUrl: (endpoint) => {\n    let ending = endpoint.startsWith('/') ? endpoint.substring(1) : endpoint\n    const url = `${synthesisServerUrl}${ending}`\n    return url\n  },\n}\n","import { context } from '../context'\n\nexport interface ReadResponseV2<T> {\n  success: boolean\n  message?: string\n  item: T | null\n}\n\nexport interface WriteResponseV2<T> {\n  success: boolean\n  message?: string\n  /* The item is returned when the write operation succeeds */\n  item?: T\n}\n\nexport interface UpdateResponseV2<T> {\n  success: boolean\n  message?: string\n  /* The item is returned when the update operation succeeds */\n  item?: T\n}\n\nexport interface DeleteResponseV2 {\n  success: boolean\n  message?: string\n}\n\nexport interface PaginationResponseV2<T> {\n  success: boolean\n  message?: string\n  page: number\n  num_pages: number\n  page_size: number\n  items: T[]\n}\n\nexport interface ErrorResponseV2 {\n  success: false\n  message: string\n}\n\nexport default {\n  get: (path: string, useSynthesisServer: boolean = false) => {\n    return fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'GET',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n      },\n    )\n  },\n  post: (\n    path: string,\n    data: Record<string, any> = {},\n    useSynthesisServer: boolean = false,\n  ) =>\n    fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'POST',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n        body: JSON.stringify(data),\n      },\n    ),\n  put: (\n    path: string,\n    data: Record<string, any> = {},\n    useSynthesisServer: boolean = false,\n  ) =>\n    fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'PUT',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n        body: JSON.stringify(data),\n      },\n    ),\n  delete: (path: string, useSynthesisServer: boolean = false) =>\n    fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'DELETE',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n      },\n    ),\n\n  errorResponse: (e: any): ErrorResponseV2 => ({\n    success: false,\n    message: `Library error: ${e}`,\n  }),\n}\n\n// https://github.com/sindresorhus/uint8array-extras\n\nexport function concatUint8Arrays(arrays: Uint8Array[], totalLength?: number) {\n  if (arrays.length === 0) {\n    return new Uint8Array(0)\n  }\n\n  totalLength ??= arrays.reduce(\n    (accumulator, currentValue) => accumulator + currentValue.length,\n    0,\n  )\n\n  const returnValue = new Uint8Array(totalLength)\n\n  let offset = 0\n  for (const array of arrays) {\n    returnValue.set(array, offset)\n    offset += array.length\n  }\n\n  return returnValue\n}\n","import UtilV2, {\n  DeleteResponseV2,\n  ErrorResponseV2,\n  PaginationResponseV2,\n  ReadResponseV2,\n  UpdateResponseV2,\n  WriteResponseV2,\n} from './util'\n\nexport interface Project {\n  uuid: string\n  name: string\n  description: string\n  is_public: boolean\n  is_collaborative: boolean\n  is_archived: boolean\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface ProjectInput {\n  name: string\n  description: string\n  is_public: boolean\n  is_collaborative: boolean\n  is_archived: boolean\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize?: number,\n  ): Promise<PaginationResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `projects?page=${page}${pageSize ? `&page_size=${pageSize}` : ''}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    uuid: string,\n  ): Promise<ReadResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(`projects/${uuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  create: async (\n    projectInput: ProjectInput,\n  ): Promise<WriteResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post('projects', projectInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  update: async (\n    uuid: string,\n    projectInput: ProjectInput,\n  ): Promise<UpdateResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.put(`projects/${uuid}`, projectInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (\n    uuid: string,\n  ): Promise<DeleteResponseV2 | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.delete(`projects/${uuid}`)\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import { concatUint8Arrays } from './util'\n\nexport const DEFAULT_BUFFER_SIZE = 4 * 1024\nexport const STREAMING_WAV_HEADER_BUFFER_LEN = 36\n\nexport const StreamDecoder = function (\n  bufferSize = DEFAULT_BUFFER_SIZE,\n  ignoreWavHeader = true,\n  timeStampsProcessingRequired = false,\n) {\n  if (bufferSize < 2) throw new Error('Buffer size cannot be less than 2')\n  if (bufferSize % 2 !== 0)\n    throw new Error('Buffer size must be evenly divisible by 2.')\n  this.bufferSize = bufferSize\n  this.ignoreWavHeader = ignoreWavHeader\n  this.chunks = []\n  this.headerBuffer = new Uint8Array()\n\n  this.processTimeStamps = timeStampsProcessingRequired\n  this.timeStampsBuffer = []\n  this.allTimestampsProcessed = false\n  this.timeStamps = {}\n}\n\nStreamDecoder.prototype.setBufferSize = function (size) {\n  if (size < 2) throw new Error('Buffer size cannot be less than 2')\n  if (size % 2 !== 0)\n    throw new Error('Buffer size must be evenly divisible by 2.')\n  this.bufferSize = size\n}\n\nStreamDecoder.prototype.setIgnoreWavHeader = function (val) {\n  this.ignoreWavHeader = val\n}\n\nStreamDecoder.prototype.decodeChunk = function (chunk: Uint8Array) {\n  // 1. assume user wants headers. no timestamps have been requested, we can store the chunks as they come\n  this.chunks.push(chunk)\n\n  // 2. user does not need headers and timestamps are also not present, so we ignore the 36 bytes (wav header size) and return the rest\n  if (\n    this.headerBuffer.length < STREAMING_WAV_HEADER_BUFFER_LEN && // check if header has been processed\n    this.ignoreWavHeader && // Check if header should be ignored\n    !this.processTimeStamps\n  ) {\n    const tempBuf = concatUint8Arrays(this.chunks)\n    if (tempBuf.length >= STREAMING_WAV_HEADER_BUFFER_LEN) {\n      this.headerBuffer = tempBuf.slice(0, STREAMING_WAV_HEADER_BUFFER_LEN) // Extract header, for next set of chunks to ignore\n      const tempDataBuffer = tempBuf.slice(STREAMING_WAV_HEADER_BUFFER_LEN) // Extract data\n\n      this.chunks = []\n      this.chunks.push(tempDataBuffer) // set the chunks with the data\n    }\n  }\n\n  // timestamps are present, keep storing them untill all timestamps have been processed\n  if (this.processTimeStamps && !this.allTimestampsProcessed) {\n    this.timeStampsBuffer.push(chunk)\n  }\n\n  // 3. user wants timestamps and headers: process the timestamps, preserve the 36 bytes and discard the timestamp bytes\n  if (!this.ignoreWavHeader && this.processTimeStamps) {\n    if (!this.allTimestampsProcessed) {\n      const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n\n      const obj = this.extractTimestampsFromBuffer(tempBuf)\n\n      // we ran past the buffer length, just preserve the header for now\n      if (!obj.timestamps) {\n        // no wav headers yet, obtain it:\n        if (this.headerBuffer.length < STREAMING_WAV_HEADER_BUFFER_LEN) {\n          const tempBuf = concatUint8Arrays(this.chunks)\n          if (tempBuf.length >= STREAMING_WAV_HEADER_BUFFER_LEN) {\n            this.headerBuffer = tempBuf.slice(\n              0,\n              STREAMING_WAV_HEADER_BUFFER_LEN,\n            )\n\n            this.chunks = []\n            this.chunks.push(this.headerBuffer)\n          }\n        } else {\n          // since header exists and we don't have timestamps yet, it means we can reset the chunk to only contain the header\n          this.chunks = []\n          this.chunks.push(this.headerBuffer)\n        }\n      }\n\n      // timestamps are present, process them\n      if (obj.timestamps && obj.timestamps !== null) {\n        if (this.headerBuffer.length < STREAMING_WAV_HEADER_BUFFER_LEN) {\n          // header not processed yet, process it and discard the timestamps bytes. also process the data bytes if any in current chunk\n          const tempBuf = concatUint8Arrays(this.chunks)\n          if (tempBuf.length >= STREAMING_WAV_HEADER_BUFFER_LEN) {\n            this.headerBuffer = tempBuf.slice(\n              0,\n              STREAMING_WAV_HEADER_BUFFER_LEN,\n            )\n\n            this.chunks = []\n            const tempDataBuffer = tempBuf.slice(obj.offset)\n            this.chunks.push(this.headerBuffer)\n            this.chunks.push(tempDataBuffer)\n          }\n        } else {\n          // header has already been processed, discard the timestamps bytes and preserve wav header and the data bytes if any\n          const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n          const tempDataBuffer = tempBuf.slice(obj.offset)\n\n          this.chunks = []\n          this.chunks.push(this.headerBuffer)\n          this.chunks.push(tempDataBuffer)\n        }\n\n        // mark all timestamps as processed\n        this.timeStamps = obj.timestamps\n        this.allTimestampsProcessed = true\n        this.timeStampsBuffer = []\n      }\n    }\n  }\n\n  // 4. timestamps are present and have been requested but no headers are wanted\n  if (this.ignoreWavHeader && this.processTimeStamps) {\n    if (!this.allTimestampsProcessed) {\n      const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n      const obj = this.extractTimestampsFromBuffer(tempBuf)\n\n      if (!obj.timestamps && obj.offset) {\n        // we haven't reached the data section yet, discard evrything\n        this.chunks = []\n      }\n\n      if (obj.timestamps && obj.timestamps !== null) {\n        this.timeStamps = obj.timestamps\n        this.allTimestampsProcessed = true\n        const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n        const tempDataBuffer = tempBuf.slice(obj.offset)\n        this.chunks = []\n        this.chunks.push(tempDataBuffer)\n      }\n    }\n  }\n}\n\nStreamDecoder.prototype.flushBuffer = function (force = false) {\n  const tempBuf = concatUint8Arrays(this.chunks)\n  if (force && tempBuf.length > 0) {\n    this.chunks = []\n    return tempBuf\n  }\n  if (tempBuf.length >= this.bufferSize) {\n    const returnBuffer = tempBuf.slice(0, this.bufferSize)\n    const leftoverBuffer = tempBuf.slice(this.bufferSize)\n    this.chunks = []\n    this.chunks.push(leftoverBuffer)\n    return returnBuffer\n  }\n  return null\n}\n\nStreamDecoder.prototype.reset = function () {\n  this.chunks = []\n  this.headerBuffer = new Uint8Array()\n}\n\nStreamDecoder.prototype.getTimestamps = function () {\n  if (this.processTimeStamps && this.allTimestampsProcessed) {\n    return this.timeStamps\n  }\n  return null\n}\n\nStreamDecoder.prototype.extractTimestampsFromBuffer = function (\n  buffer: Uint8Array,\n) {\n  let offset = 0\n  offset += 4 // Skip RIFF ID\n\n  offset += 4 // skip remaining file size\n  offset += 14 // skp RIFF type (WAVE), format chunk id, chunk data size, and compression code\n\n  const dataView = new DataView(\n    buffer.buffer,\n    buffer.byteOffset,\n    buffer.byteLength,\n  )\n\n  let [nChannels, sampleRate] = [\n    dataView.getUint16(offset, true), // read number of channels\n    dataView.getUint32(offset + 2, true), // and sample rate\n  ]\n  offset += 14 // skip byte rate, block align and bits per sample at this point we have covered the Header & Format chunks: https://docs.app.resemble.ai/docs/resource_clip/stream#header--format-chunks\n\n  const textDecoder = new TextDecoder('ascii')\n\n  let chunkType = textDecoder.decode(\n    new Uint8Array(buffer.buffer, buffer.byteOffset + offset, 4),\n  ) // now we are at Timestamps (cue, list & ltxt chunks): https://docs.app.resemble.ai/docs/resource_clip/stream#timestamps-cue-list--ltxt-chunks\n\n  offset += 4\n  const timestamps = {\n    graph_chars: [],\n    graph_times: [],\n    phon_chars: [],\n    phon_times: [],\n  }\n\n  if (chunkType === 'cue ') {\n    let [remSize, nCuePoints] = [\n      dataView.getUint32(offset, true), // Remaining size of the cue chunk\n      dataView.getUint32(offset + 4, true), // Number of remaining cue points\n    ]\n    offset += 8 // skip to the first cue point\n    let endPoint = offset + remSize - 4 // we subtract 4 to account for the \"n_cue_points\" field size\n\n    let cuePoints = {}\n\n    // start from the first cue point and read all cue points\n    // each cue point is 24 bytes long\n\n    if (endPoint > buffer.length) {\n      return { timestamps: null, offset }\n    }\n    for (let cp = 1; cp <= nCuePoints; cp++) {\n      const idx = dataView.getUint32(offset, true)\n      const cuePoint = dataView.getUint32(offset + 20, true)\n      cuePoints[idx] = cuePoint\n      offset += 24\n    }\n\n    // now the offset is at the beginning of the LIST chunk, remember we are processing in the little-endian order\n    chunkType = textDecoder.decode(\n      new Uint8Array(buffer.buffer, buffer.byteOffset + offset, 4),\n    ) // read the LIST chunk type\n    remSize = dataView.getUint32(offset + 4, true)\n    offset += 12 // arrive at the start of first LTXT chunk\n\n    let listEndPoint = offset + remSize - 4 // we subtract 4 to account for the \"rem size\" field\n\n    if (listEndPoint > buffer.length) {\n      return { timestamps: null, offset }\n    }\n\n    // start from the first LTXT chunk and read all LTXT chunks\n    while (offset < listEndPoint) {\n      const subChunkSize = dataView.getUint32(offset + 4, true) // Remaining size of this ltxt chunk after this read\n      const cueIdx = dataView.getUint32(offset + 8, true)\n      const nSamples = dataView.getUint32(offset + 12, true)\n      let charTypeRaw = textDecoder.decode(\n        new Uint8Array(buffer.buffer, buffer.byteOffset + offset + 16, 4),\n      ) // \"grph\" OR \"phon\"\n      let charType = charTypeRaw.trim()\n\n      offset += 28\n\n      const textLen = subChunkSize - 20\n      const utf8Decoder = new TextDecoder('utf-8')\n      const text = utf8Decoder.decode(\n        new Uint8Array(buffer.buffer, buffer.byteOffset + offset, textLen - 1),\n      ) // -1 to remove the null character at the end\n\n      offset += textLen\n      offset += textLen % 2\n\n      const typeMapping = {\n        grph: 'graph',\n        phon: 'phon',\n      }\n      let mappedType = typeMapping[charType]\n\n      timestamps[`${mappedType}_chars`].push(text)\n      timestamps[`${mappedType}_times`].push([\n        cuePoints[cueIdx] / sampleRate,\n        (cuePoints[cueIdx] + nSamples) / sampleRate,\n      ])\n    }\n\n    return {\n      timestamps: timestamps,\n      offset,\n    }\n  } else {\n    return {\n      timestamps: null,\n    }\n  }\n}\n","import UtilV2, {\n  ErrorResponseV2,\n  PaginationResponseV2,\n  ReadResponseV2,\n  WriteResponseV2,\n} from './util'\nimport { DEFAULT_BUFFER_SIZE, StreamDecoder } from './StreamDecoder'\n\nexport interface Clip {\n  uuid: string\n  title: string\n  body: string\n  voice_uuid: string\n  is_public: boolean\n  is_archived: boolean\n  timestamps?: any\n  audio_src?: string\n  raw_audio?: any\n  created_at: Date\n  updated_at: Date\n}\n\ninterface ClipInput {\n  title?: string\n  body: string\n  voice_uuid: string\n  is_public: boolean\n  is_archived: boolean\n  sample_rate?: 16000 | 22050 | 44100\n  output_format?: 'wav' | 'mp3'\n  precision?: 'PCM_16' | 'PCM_32'\n  include_timestamps?: boolean\n}\n\nexport interface SyncClipInput extends ClipInput {\n  raw?: boolean\n}\n\nexport interface AsyncClipInput extends ClipInput {\n  callback_uri: string\n}\n\nexport interface DirectClipInput {\n  voice_uuid: string\n  project_uuid: string\n  title?: string\n  data: string\n  precision?: 'MULAW' | 'PCM_16' | 'PCM_24' | 'PCM_32'\n  output_format?: 'wav' | 'mp3'\n}\n\nexport interface DirectClip {\n  success: true\n  audio_content: string\n  audio_timestamps: {\n    graph_chars: string[]\n    graph_times: [number, number][]\n    phon_chars: string[]\n    phon_times: [number, number][]\n  }\n  duration: number\n  synth_duration: number\n  output_format: 'wav' | 'mp3'\n  sample_rate: number\n  issues: string[]\n}\n\nexport interface DirectClipError {\n  success: false\n  issues?: string[]\n  error_name: string\n  error_params: unknown\n  feedback_uuid: string\n  message: string\n}\n\nexport interface StreamInput {\n  data: string\n  project_uuid: string\n  voice_uuid: string\n  sample_rate?: 8000 | 16000 | 22050 | 44100 | 32000\n  precision?: 'MULAW' | 'PCM_16' | 'PCM_32'\n}\n\nexport interface StreamConfig {\n  bufferSize?: number\n  ignoreWavHeader?: boolean\n  getTimeStamps?: boolean\n}\n\nconst create = async (projectUuid: string, clipInput: ClipInput) => {\n  try {\n    const response = await UtilV2.post(\n      `projects/${projectUuid}/clips`,\n      clipInput,\n    )\n    let json = await response.json()\n    if (json.success) {\n      json = {\n        ...json,\n        item: {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        },\n      }\n    }\n    return json\n  } catch (e) {\n    return UtilV2.errorResponse(e)\n  }\n}\n\nexport default {\n  all: async (\n    projectUuid: string,\n    page: number,\n    pageSize: number,\n  ): Promise<PaginationResponseV2<Clip> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `projects/${projectUuid}/clips?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      const json = await response.json()\n      if (json.success)\n        json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    projectUuid: string,\n    uuid: string,\n  ): Promise<ReadResponseV2<Clip> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(`projects/${projectUuid}/clips/${uuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  createAsync: async (\n    projectUuid: string,\n    clipInput: AsyncClipInput,\n  ): Promise<WriteResponseV2<Clip> | ErrorResponseV2> => {\n    return create(projectUuid, clipInput)\n  },\n\n  createSync: async (\n    projectUuid: string,\n    clipInput: SyncClipInput,\n  ): Promise<WriteResponseV2<Clip> | ErrorResponseV2> => {\n    return create(projectUuid, clipInput)\n  },\n\n  createDirect: async (\n    clipInput: DirectClipInput,\n  ): Promise<DirectClip | DirectClipError | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post('synthesize', clipInput, true)\n      let json = await response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  stream: async function* (\n    streamInput: StreamInput,\n    streamConfig?: StreamConfig,\n  ): AsyncGenerator {\n    const defaultStreamConfig = {\n      bufferSize: DEFAULT_BUFFER_SIZE,\n      ignoreWavHeader: false,\n      getTimeStamps: false,\n    }\n\n    const getTimeStamps =\n      streamConfig?.getTimeStamps || defaultStreamConfig.getTimeStamps\n    const bufferSize =\n      streamConfig?.bufferSize || defaultStreamConfig.bufferSize\n    const ignoreWavHeader =\n      streamConfig?.ignoreWavHeader || defaultStreamConfig.ignoreWavHeader\n\n    try {\n      const response = await UtilV2.post(\n        'stream',\n        {\n          ...streamInput,\n          wav_encoded_timestamps: getTimeStamps,\n        },\n        true,\n      )\n\n      // check for error response\n      if (!response.ok || !response.body) {\n        const isJson = response.headers\n          .get('content-type')\n          ?.includes('application/json')\n        const data = isJson ? await response.json() : null\n        const error = (data && data.message) || response.status\n        throw Error(error)\n      }\n\n      const streamDecoder = new StreamDecoder(\n        bufferSize,\n        ignoreWavHeader,\n        getTimeStamps,\n      )\n      streamDecoder.reset()\n\n      const reader = response.body.getReader()\n\n      // Iterate over the stream and start decoding, and returning data\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read()\n          if (done) break\n\n          streamDecoder.decodeChunk(value)\n          const buffer = streamDecoder.flushBuffer()\n          if (buffer !== null) {\n            yield {\n              data: buffer,\n              timestamps: streamDecoder.getTimestamps(),\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock()\n      }\n\n      // Keep draining the buffer until the buffer.length < bufferSize or buffer.length == 0\n      let buffer = streamDecoder.flushBuffer()\n      while (buffer !== null) {\n        const buffToReturn = new Uint8Array(buffer)\n        buffer = streamDecoder.flushBuffer()\n        yield {\n          data: buffToReturn,\n          timestamps: streamDecoder.getTimestamps(),\n        }\n      }\n\n      // Drain any leftover content in the buffer, buffer.length will always be less than bufferSize here\n      buffer = streamDecoder.flushBuffer(true)\n      if (buffer !== null)\n        yield {\n          data: buffer,\n          timestamps: streamDecoder.getTimestamps(),\n        }\n    } catch (e) {\n      // If an error occurs and the catch block is executed, the function will return a plain object (UtilV2.errorResponse(e)).\n      // This will cause the function to not return an async iterable, leading to an error, so we need to throw the error\n      throw e\n    }\n  },\n\n  updateAsync: async (\n    projectUuid: string,\n    uuid: string,\n    clipInput: AsyncClipInput,\n  ) => {\n    try {\n      const response = await UtilV2.put(\n        `projects/${projectUuid}/clips/${uuid}`,\n        clipInput,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (projectUuid: string, uuid: string) => {\n    try {\n      const response = await UtilV2.delete(\n        `projects/${projectUuid}/clips/${uuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import fetch from 'isomorphic-fetch'\nimport FormData from 'isomorphic-form-data'\nimport { context } from '../context'\nimport UtilV2, {\n  ErrorResponseV2,\n  PaginationResponseV2,\n  UpdateResponseV2,\n  DeleteResponseV2,\n  ReadResponseV2,\n  WriteResponseV2,\n} from './util'\n\nexport interface Recording {\n  uuid: string\n  name: string\n  text: string\n  emotion: string\n  is_active: boolean\n  audio_src: string\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface RecordingInput {\n  name: string\n  text: string\n  emotion: string\n  is_active: boolean\n}\n\nexport default {\n  all: async (\n    voiceUuid: string,\n    page: number,\n    pageSize: number,\n  ): Promise<PaginationResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `voices/${voiceUuid}/recordings?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      const json = await response.json()\n      if (json.success)\n        json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    voiceUuid: string,\n    uuid: string,\n  ): Promise<ReadResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `voices/${voiceUuid}/recordings/${uuid}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  create: async (\n    voiceUuid: string,\n    recordingInput: RecordingInput,\n    buffer: Buffer,\n    fileSizeInBytes: number,\n  ): Promise<WriteResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const formData = new FormData()\n      formData.append('name', recordingInput.name)\n      formData.append('text', recordingInput.text)\n      formData.append('emotion', recordingInput.emotion)\n      formData.append('is_active', recordingInput.is_active ? 'true' : 'false')\n      formData.append('file', buffer, { knownLength: fileSizeInBytes })\n\n      const response = await fetch(\n        context.endpoint('v2', `voices/${voiceUuid}/recordings`),\n        {\n          method: 'POST',\n          headers: {\n            Authorization: context.headers().Authorization,\n            'Content-Type': 'multipart/form-data',\n            ...(formData.getHeaders ? formData.getHeaders() : {}),\n          },\n          body: formData,\n        },\n      )\n\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  update: async (\n    voiceUuid: string,\n    uuid: string,\n    recordingInput: RecordingInput,\n  ): Promise<UpdateResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.put(\n        `voices/${voiceUuid}/recordings/${uuid}`,\n        recordingInput,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (\n    voiceUuid: string,\n    uuid: string,\n  ): Promise<DeleteResponseV2 | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.delete(\n        `voices/${voiceUuid}/recordings/${uuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import UtilV2, {\n  DeleteResponseV2,\n  ErrorResponseV2,\n  PaginationResponseV2,\n  ReadResponseV2,\n  UpdateResponseV2,\n  WriteResponseV2,\n} from './util'\n\nexport interface Voice {\n  uuid: string\n  name: string\n  status: string\n  default_language: string\n  supported_languages: string[]\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface VoiceInput {\n  name: string\n  dataset_url?: string\n  callback_uri?: string\n  consent?: string\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize: number,\n  ): Promise<PaginationResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `voices?page=${page}${pageSize ? `&page_size=${pageSize}` : ''}`,\n      )\n      const json = await response.json()\n      if (json.success)\n        json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    uuid: string,\n  ): Promise<ReadResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(`voices/${uuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  create: async (\n    voiceInput: VoiceInput,\n  ): Promise<WriteResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post('voices', voiceInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  update: async (\n    uuid: string,\n    voiceInput: VoiceInput,\n  ): Promise<UpdateResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.put(`voices/${uuid}`, voiceInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (\n    uuid: string,\n  ): Promise<DeleteResponseV2 | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.delete(`voices/${uuid}`)\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  build: async (\n    uuid: string,\n  ): Promise<{ success: boolean; message?: string } | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post(`voices/${uuid}/build`)\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import UtilV2, { ErrorResponseV2, PaginationResponseV2 } from './util'\n\nexport interface Batch {\n  uuid: string\n  body: Array<[string, string]>\n  voice_uuid: string\n  callback_uri?: string\n  total_count: number\n  completed_count: number\n  failed_count: number\n  created_at: Date\n  updated_at: Date\n}\n\nexport default {\n  all: async (\n    projectUuid: string,\n    page: number,\n    pageSize?: number,\n  ): Promise<PaginationResponseV2<Batch> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `projects/${projectUuid}/batch?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item: Batch) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  create: async (\n    projectUuid: string,\n    voiceUuid: string,\n    body: string[] | Array<[string, string]>,\n    batchInputConfig: {\n      callbackUri: string\n      precision: 'PCM_32' | 'PCM_16' | 'MULAW'\n      sampleRate: 8000 | 16000 | 22050 | 44100\n      outputFormat: 'wav' | 'mp3'\n    },\n  ) => {\n    try {\n      const options = {\n        body: body,\n        voice_uuid: voiceUuid,\n        sample_rate: batchInputConfig?.sampleRate,\n        output_format: batchInputConfig?.outputFormat,\n        precision: batchInputConfig?.precision,\n      }\n      if (batchInputConfig?.callbackUri) {\n        options['callback_uri'] = batchInputConfig?.callbackUri\n      }\n      const response = await UtilV2.post(\n        `/projects/${projectUuid}/batch`,\n        options,\n      )\n\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  get: async (projectUuid: string, batchUuid: string) => {\n    try {\n      const response = await UtilV2.get(\n        `projects/${projectUuid}/batch/${batchUuid}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n  delete: async (projectUuid: string, batchUuid: string) => {\n    try {\n      const response = await UtilV2.delete(\n        `projects/${projectUuid}/batch/${batchUuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import UtilV2, { ErrorResponseV2, PaginationResponseV2 } from './util'\n\nexport interface Phoneme {\n  uuid: string\n  alphabet: string\n  word: string\n  phonetic_transcription: string\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface AllPhonemeResponse {\n  success: boolean\n  page: number\n  num_pages: number\n  page_size: number\n  items: Phoneme[]\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize?: number,\n  ): Promise<PaginationResponseV2<AllPhonemeResponse> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `phonemes?page=${page}${pageSize ? `&page_size=${pageSize}` : ''}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item: Phoneme) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  create: async (word: string, phonetic_transcription: string) => {\n    try {\n      const response = await UtilV2.post('phonemes', {\n        word,\n        phonetic_transcription,\n      })\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  get: async (phonemeUuid: string) => {\n    try {\n      const response = await UtilV2.get(`phonemes/${phonemeUuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  delete: async (phoneme_uuid: string) => {\n    try {\n      const response = await UtilV2.delete(`phonemes/${phoneme_uuid}`)\n      const json = response.json()\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n}\n","import UtilV2, { ErrorResponseV2, PaginationResponseV2 } from './util'\n\nexport interface TermSubstitution {\n  uuid: string\n  original_text: string\n  replacement_text: string\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface AllTermSubstitutionResponse {\n  success: boolean\n  page: number\n  num_pages: number\n  page_size: number\n  items: TermSubstitution[]\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize?: number,\n  ): Promise<\n    PaginationResponseV2<AllTermSubstitutionResponse> | ErrorResponseV2\n  > => {\n    try {\n      const response = await UtilV2.get(\n        `term_substitutions?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item: TermSubstitution) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  create: async (original_text: string, replacement_text: string) => {\n    try {\n      const response = await UtilV2.post('term_substitutions', {\n        original_text,\n        replacement_text,\n      })\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  get: async (termSubstitutionUuid: string) => {\n    try {\n      const response = await UtilV2.get(\n        `term_substitutions/${termSubstitutionUuid}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  delete: async (termSubstitutionUuid: string) => {\n    try {\n      const response = await UtilV2.delete(\n        `term_substitutions/${termSubstitutionUuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n}\n","import { context } from './context'\nimport ProjectsV2 from './v2/projects'\nimport ClipsV2 from './v2/clips'\nimport RecordingsV2 from './v2/recordings'\nimport VoicesV2 from './v2/voices'\nimport BatchV2 from './v2/batch'\nimport PhonemesV2 from './v2/phonemes'\nimport TermSubstitutionsV2 from './v2/termSubstitutions'\n\nexport const Resemble = {\n  setApiKey: context.setApiKey,\n  setBaseUrl: context.setBaseUrl,\n  setSynthesisUrl: context.setSynthesisUrl,\n\n  v2: {\n    projects: {\n      all: ProjectsV2.all,\n      create: ProjectsV2.create,\n      update: ProjectsV2.update,\n      get: ProjectsV2.get,\n      delete: ProjectsV2.destroy,\n    },\n    clips: {\n      all: ClipsV2.all,\n      createSync: ClipsV2.createSync,\n      createAsync: ClipsV2.createAsync,\n      createDirect: ClipsV2.createDirect,\n      updateAsync: ClipsV2.updateAsync,\n      stream: ClipsV2.stream,\n      get: ClipsV2.get,\n      delete: ClipsV2.destroy,\n    },\n    voices: {\n      all: VoicesV2.all,\n      create: VoicesV2.create,\n      update: VoicesV2.update,\n      build: VoicesV2.build,\n      get: VoicesV2.get,\n      delete: VoicesV2.destroy,\n    },\n    recordings: {\n      all: RecordingsV2.all,\n      get: RecordingsV2.get,\n      create: RecordingsV2.create,\n      update: RecordingsV2.update,\n      delete: RecordingsV2.destroy,\n    },\n    batch: {\n      all: BatchV2.all,\n      get: BatchV2.get,\n      create: BatchV2.create,\n      delete: BatchV2.delete,\n    },\n    phonemes: {\n      all: PhonemesV2.all,\n      create: PhonemesV2.create,\n      get: PhonemesV2.get,\n      delete: PhonemesV2.delete,\n    },\n    termSubstitutions: {\n      all: TermSubstitutionsV2.all,\n      get: TermSubstitutionsV2.get,\n      create: TermSubstitutionsV2.create,\n      delete: TermSubstitutionsV2.delete,\n    },\n  },\n}\n"],"names":["apiKey","baseUrl","synthesisServerHeaders","Authorization","context","headers","setBaseUrl","url","endsWith","setApiKey","key","setSynthesisUrl","synthesisServerUrl","endpoint","version","ending","startsWith","substring","synServerUrl","UtilV2","path","useSynthesisServer","fetch","method","data","body","JSON","stringify","e","success","message","arrays","totalLength","length","Uint8Array","reduce","accumulator","currentValue","returnValue","array","set","offset","ProjectsV2","all","async","page","pageSize","json","response","items","map","item","_extends","created_at","Date","updated_at","get","uuid","create","projectInput","update","destroy","StreamDecoder","bufferSize","ignoreWavHeader","timeStampsProcessingRequired","Error","this","chunks","headerBuffer","processTimeStamps","timeStampsBuffer","allTimestampsProcessed","timeStamps","prototype","setBufferSize","size","setIgnoreWavHeader","val","decodeChunk","chunk","push","tempBuf","concatUint8Arrays","slice","tempDataBuffer","extractTimestampsFromBuffer","obj","timestamps","flushBuffer","force","returnBuffer","leftoverBuffer","reset","getTimestamps","buffer","dataView","DataView","byteOffset","byteLength","nChannels","sampleRate","getUint16","getUint32","textDecoder","TextDecoder","chunkType","decode","graph_chars","graph_times","phon_chars","phon_times","remSize","nCuePoints","cp","cuePoint","cuePoints","idx","listEndPoint","subChunkSize","nSamples","charType","trim","textLen","mappedType","grph","phon","text","cueIdx","projectUuid","clipInput","_ref","ClipsV2","createAsync","createSync","createDirect","stream","streamInput","streamConfig","getTimeStamps","_awaitAsyncGenerator","wav_encoded_timestamps","ok","_response$headers$get","includes","status","streamDecoder","reader","getReader","done","value","read","releaseLock","buffToReturn","_x","_x2","apply","arguments","updateAsync","RecordingsV2","voiceUuid","recordingInput","fileSizeInBytes","formData","FormData","append","name","emotion","is_active","knownLength","getHeaders","VoicesV2","voiceInput","build","BatchV2","error","batchInputConfig","options","voice_uuid","sample_rate","output_format","outputFormat","precision","callbackUri","batchUuid","delete","PhonemesV2","word","phonetic_transcription","phonemeUuid","phoneme_uuid","TermSubstitutionsV2","original_text","replacement_text","termSubstitutionUuid","Resemble","v2","projects","clips","voices","recordings","batch","phonemes","termSubstitutions"],"mappings":"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"}