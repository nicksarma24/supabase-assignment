{"version":3,"file":"resemble.umd.js","sources":["../src/context.ts","../src/v2/util.ts","../src/v2/projects.ts","../src/v2/StreamDecoder.ts","../src/v2/clips.ts","../src/v2/recordings.ts","../src/v2/voices.ts","../src/v2/batch.ts","../src/v2/phonemes.ts","../src/v2/termSubstitutions.ts","../src/resemble.ts"],"sourcesContent":["let apiKey: string | undefined = ''\nlet baseUrl: string | undefined = 'https://app.resemble.ai/api/'\nlet synthesisServerUrl: string | undefined = ''\n\nconst synthesisServerHeaders: Record<string, string> = {\n  'Content-Type': 'application/json',\n  'x-access-token': apiKey,\n}\n\nconst headers: Record<string, string> = {\n  'Content-Type': 'application/json',\n  Authorization: `Token token=${apiKey}`,\n}\n\nexport const context = {\n  headers: () => headers,\n  synthesisServerHeaders: () => synthesisServerHeaders,\n\n  setBaseUrl: (url: string) => {\n    baseUrl = url\n\n    if (!url.endsWith('/')) {\n      baseUrl += '/'\n    }\n  },\n\n  setApiKey: (key: string) => {\n    apiKey = key\n    headers['Authorization'] = `Token token=${key}`\n    synthesisServerHeaders['x-access-token'] = key\n  },\n\n  setSynthesisUrl: (url: string) => {\n    synthesisServerUrl = url\n\n    if (!url.endsWith('/')) {\n      synthesisServerUrl += '/'\n    }\n  },\n\n  endpoint: (version: string, endpoint: string): string => {\n    let ending = endpoint.startsWith('/') ? endpoint.substring(1) : endpoint\n    return `${baseUrl}${version}/${ending}`\n  },\n\n  synServerUrl: (endpoint) => {\n    let ending = endpoint.startsWith('/') ? endpoint.substring(1) : endpoint\n    const url = `${synthesisServerUrl}${ending}`\n    return url\n  },\n}\n","import { context } from '../context'\n\nexport interface ReadResponseV2<T> {\n  success: boolean\n  message?: string\n  item: T | null\n}\n\nexport interface WriteResponseV2<T> {\n  success: boolean\n  message?: string\n  /* The item is returned when the write operation succeeds */\n  item?: T\n}\n\nexport interface UpdateResponseV2<T> {\n  success: boolean\n  message?: string\n  /* The item is returned when the update operation succeeds */\n  item?: T\n}\n\nexport interface DeleteResponseV2 {\n  success: boolean\n  message?: string\n}\n\nexport interface PaginationResponseV2<T> {\n  success: boolean\n  message?: string\n  page: number\n  num_pages: number\n  page_size: number\n  items: T[]\n}\n\nexport interface ErrorResponseV2 {\n  success: false\n  message: string\n}\n\nexport default {\n  get: (path: string, useSynthesisServer: boolean = false) => {\n    return fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'GET',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n      },\n    )\n  },\n  post: (\n    path: string,\n    data: Record<string, any> = {},\n    useSynthesisServer: boolean = false,\n  ) =>\n    fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'POST',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n        body: JSON.stringify(data),\n      },\n    ),\n  put: (\n    path: string,\n    data: Record<string, any> = {},\n    useSynthesisServer: boolean = false,\n  ) =>\n    fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'PUT',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n        body: JSON.stringify(data),\n      },\n    ),\n  delete: (path: string, useSynthesisServer: boolean = false) =>\n    fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'DELETE',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n      },\n    ),\n\n  errorResponse: (e: any): ErrorResponseV2 => ({\n    success: false,\n    message: `Library error: ${e}`,\n  }),\n}\n\n// https://github.com/sindresorhus/uint8array-extras\n\nexport function concatUint8Arrays(arrays: Uint8Array[], totalLength?: number) {\n  if (arrays.length === 0) {\n    return new Uint8Array(0)\n  }\n\n  totalLength ??= arrays.reduce(\n    (accumulator, currentValue) => accumulator + currentValue.length,\n    0,\n  )\n\n  const returnValue = new Uint8Array(totalLength)\n\n  let offset = 0\n  for (const array of arrays) {\n    returnValue.set(array, offset)\n    offset += array.length\n  }\n\n  return returnValue\n}\n","import UtilV2, {\n  DeleteResponseV2,\n  ErrorResponseV2,\n  PaginationResponseV2,\n  ReadResponseV2,\n  UpdateResponseV2,\n  WriteResponseV2,\n} from './util'\n\nexport interface Project {\n  uuid: string\n  name: string\n  description: string\n  is_public: boolean\n  is_collaborative: boolean\n  is_archived: boolean\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface ProjectInput {\n  name: string\n  description: string\n  is_public: boolean\n  is_collaborative: boolean\n  is_archived: boolean\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize?: number,\n  ): Promise<PaginationResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `projects?page=${page}${pageSize ? `&page_size=${pageSize}` : ''}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    uuid: string,\n  ): Promise<ReadResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(`projects/${uuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  create: async (\n    projectInput: ProjectInput,\n  ): Promise<WriteResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post('projects', projectInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  update: async (\n    uuid: string,\n    projectInput: ProjectInput,\n  ): Promise<UpdateResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.put(`projects/${uuid}`, projectInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (\n    uuid: string,\n  ): Promise<DeleteResponseV2 | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.delete(`projects/${uuid}`)\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import { concatUint8Arrays } from './util'\n\nexport const DEFAULT_BUFFER_SIZE = 4 * 1024\nexport const STREAMING_WAV_HEADER_BUFFER_LEN = 36\n\nexport const StreamDecoder = function (\n  bufferSize = DEFAULT_BUFFER_SIZE,\n  ignoreWavHeader = true,\n  timeStampsProcessingRequired = false,\n) {\n  if (bufferSize < 2) throw new Error('Buffer size cannot be less than 2')\n  if (bufferSize % 2 !== 0)\n    throw new Error('Buffer size must be evenly divisible by 2.')\n  this.bufferSize = bufferSize\n  this.ignoreWavHeader = ignoreWavHeader\n  this.chunks = []\n  this.headerBuffer = new Uint8Array()\n\n  this.processTimeStamps = timeStampsProcessingRequired\n  this.timeStampsBuffer = []\n  this.allTimestampsProcessed = false\n  this.timeStamps = {}\n}\n\nStreamDecoder.prototype.setBufferSize = function (size) {\n  if (size < 2) throw new Error('Buffer size cannot be less than 2')\n  if (size % 2 !== 0)\n    throw new Error('Buffer size must be evenly divisible by 2.')\n  this.bufferSize = size\n}\n\nStreamDecoder.prototype.setIgnoreWavHeader = function (val) {\n  this.ignoreWavHeader = val\n}\n\nStreamDecoder.prototype.decodeChunk = function (chunk: Uint8Array) {\n  // 1. assume user wants headers. no timestamps have been requested, we can store the chunks as they come\n  this.chunks.push(chunk)\n\n  // 2. user does not need headers and timestamps are also not present, so we ignore the 36 bytes (wav header size) and return the rest\n  if (\n    this.headerBuffer.length < STREAMING_WAV_HEADER_BUFFER_LEN && // check if header has been processed\n    this.ignoreWavHeader && // Check if header should be ignored\n    !this.processTimeStamps\n  ) {\n    const tempBuf = concatUint8Arrays(this.chunks)\n    if (tempBuf.length >= STREAMING_WAV_HEADER_BUFFER_LEN) {\n      this.headerBuffer = tempBuf.slice(0, STREAMING_WAV_HEADER_BUFFER_LEN) // Extract header, for next set of chunks to ignore\n      const tempDataBuffer = tempBuf.slice(STREAMING_WAV_HEADER_BUFFER_LEN) // Extract data\n\n      this.chunks = []\n      this.chunks.push(tempDataBuffer) // set the chunks with the data\n    }\n  }\n\n  // timestamps are present, keep storing them untill all timestamps have been processed\n  if (this.processTimeStamps && !this.allTimestampsProcessed) {\n    this.timeStampsBuffer.push(chunk)\n  }\n\n  // 3. user wants timestamps and headers: process the timestamps, preserve the 36 bytes and discard the timestamp bytes\n  if (!this.ignoreWavHeader && this.processTimeStamps) {\n    if (!this.allTimestampsProcessed) {\n      const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n\n      const obj = this.extractTimestampsFromBuffer(tempBuf)\n\n      // we ran past the buffer length, just preserve the header for now\n      if (!obj.timestamps) {\n        // no wav headers yet, obtain it:\n        if (this.headerBuffer.length < STREAMING_WAV_HEADER_BUFFER_LEN) {\n          const tempBuf = concatUint8Arrays(this.chunks)\n          if (tempBuf.length >= STREAMING_WAV_HEADER_BUFFER_LEN) {\n            this.headerBuffer = tempBuf.slice(\n              0,\n              STREAMING_WAV_HEADER_BUFFER_LEN,\n            )\n\n            this.chunks = []\n            this.chunks.push(this.headerBuffer)\n          }\n        } else {\n          // since header exists and we don't have timestamps yet, it means we can reset the chunk to only contain the header\n          this.chunks = []\n          this.chunks.push(this.headerBuffer)\n        }\n      }\n\n      // timestamps are present, process them\n      if (obj.timestamps && obj.timestamps !== null) {\n        if (this.headerBuffer.length < STREAMING_WAV_HEADER_BUFFER_LEN) {\n          // header not processed yet, process it and discard the timestamps bytes. also process the data bytes if any in current chunk\n          const tempBuf = concatUint8Arrays(this.chunks)\n          if (tempBuf.length >= STREAMING_WAV_HEADER_BUFFER_LEN) {\n            this.headerBuffer = tempBuf.slice(\n              0,\n              STREAMING_WAV_HEADER_BUFFER_LEN,\n            )\n\n            this.chunks = []\n            const tempDataBuffer = tempBuf.slice(obj.offset)\n            this.chunks.push(this.headerBuffer)\n            this.chunks.push(tempDataBuffer)\n          }\n        } else {\n          // header has already been processed, discard the timestamps bytes and preserve wav header and the data bytes if any\n          const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n          const tempDataBuffer = tempBuf.slice(obj.offset)\n\n          this.chunks = []\n          this.chunks.push(this.headerBuffer)\n          this.chunks.push(tempDataBuffer)\n        }\n\n        // mark all timestamps as processed\n        this.timeStamps = obj.timestamps\n        this.allTimestampsProcessed = true\n        this.timeStampsBuffer = []\n      }\n    }\n  }\n\n  // 4. timestamps are present and have been requested but no headers are wanted\n  if (this.ignoreWavHeader && this.processTimeStamps) {\n    if (!this.allTimestampsProcessed) {\n      const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n      const obj = this.extractTimestampsFromBuffer(tempBuf)\n\n      if (!obj.timestamps && obj.offset) {\n        // we haven't reached the data section yet, discard evrything\n        this.chunks = []\n      }\n\n      if (obj.timestamps && obj.timestamps !== null) {\n        this.timeStamps = obj.timestamps\n        this.allTimestampsProcessed = true\n        const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n        const tempDataBuffer = tempBuf.slice(obj.offset)\n        this.chunks = []\n        this.chunks.push(tempDataBuffer)\n      }\n    }\n  }\n}\n\nStreamDecoder.prototype.flushBuffer = function (force = false) {\n  const tempBuf = concatUint8Arrays(this.chunks)\n  if (force && tempBuf.length > 0) {\n    this.chunks = []\n    return tempBuf\n  }\n  if (tempBuf.length >= this.bufferSize) {\n    const returnBuffer = tempBuf.slice(0, this.bufferSize)\n    const leftoverBuffer = tempBuf.slice(this.bufferSize)\n    this.chunks = []\n    this.chunks.push(leftoverBuffer)\n    return returnBuffer\n  }\n  return null\n}\n\nStreamDecoder.prototype.reset = function () {\n  this.chunks = []\n  this.headerBuffer = new Uint8Array()\n}\n\nStreamDecoder.prototype.getTimestamps = function () {\n  if (this.processTimeStamps && this.allTimestampsProcessed) {\n    return this.timeStamps\n  }\n  return null\n}\n\nStreamDecoder.prototype.extractTimestampsFromBuffer = function (\n  buffer: Uint8Array,\n) {\n  let offset = 0\n  offset += 4 // Skip RIFF ID\n\n  offset += 4 // skip remaining file size\n  offset += 14 // skp RIFF type (WAVE), format chunk id, chunk data size, and compression code\n\n  const dataView = new DataView(\n    buffer.buffer,\n    buffer.byteOffset,\n    buffer.byteLength,\n  )\n\n  let [nChannels, sampleRate] = [\n    dataView.getUint16(offset, true), // read number of channels\n    dataView.getUint32(offset + 2, true), // and sample rate\n  ]\n  offset += 14 // skip byte rate, block align and bits per sample at this point we have covered the Header & Format chunks: https://docs.app.resemble.ai/docs/resource_clip/stream#header--format-chunks\n\n  const textDecoder = new TextDecoder('ascii')\n\n  let chunkType = textDecoder.decode(\n    new Uint8Array(buffer.buffer, buffer.byteOffset + offset, 4),\n  ) // now we are at Timestamps (cue, list & ltxt chunks): https://docs.app.resemble.ai/docs/resource_clip/stream#timestamps-cue-list--ltxt-chunks\n\n  offset += 4\n  const timestamps = {\n    graph_chars: [],\n    graph_times: [],\n    phon_chars: [],\n    phon_times: [],\n  }\n\n  if (chunkType === 'cue ') {\n    let [remSize, nCuePoints] = [\n      dataView.getUint32(offset, true), // Remaining size of the cue chunk\n      dataView.getUint32(offset + 4, true), // Number of remaining cue points\n    ]\n    offset += 8 // skip to the first cue point\n    let endPoint = offset + remSize - 4 // we subtract 4 to account for the \"n_cue_points\" field size\n\n    let cuePoints = {}\n\n    // start from the first cue point and read all cue points\n    // each cue point is 24 bytes long\n\n    if (endPoint > buffer.length) {\n      return { timestamps: null, offset }\n    }\n    for (let cp = 1; cp <= nCuePoints; cp++) {\n      const idx = dataView.getUint32(offset, true)\n      const cuePoint = dataView.getUint32(offset + 20, true)\n      cuePoints[idx] = cuePoint\n      offset += 24\n    }\n\n    // now the offset is at the beginning of the LIST chunk, remember we are processing in the little-endian order\n    chunkType = textDecoder.decode(\n      new Uint8Array(buffer.buffer, buffer.byteOffset + offset, 4),\n    ) // read the LIST chunk type\n    remSize = dataView.getUint32(offset + 4, true)\n    offset += 12 // arrive at the start of first LTXT chunk\n\n    let listEndPoint = offset + remSize - 4 // we subtract 4 to account for the \"rem size\" field\n\n    if (listEndPoint > buffer.length) {\n      return { timestamps: null, offset }\n    }\n\n    // start from the first LTXT chunk and read all LTXT chunks\n    while (offset < listEndPoint) {\n      const subChunkSize = dataView.getUint32(offset + 4, true) // Remaining size of this ltxt chunk after this read\n      const cueIdx = dataView.getUint32(offset + 8, true)\n      const nSamples = dataView.getUint32(offset + 12, true)\n      let charTypeRaw = textDecoder.decode(\n        new Uint8Array(buffer.buffer, buffer.byteOffset + offset + 16, 4),\n      ) // \"grph\" OR \"phon\"\n      let charType = charTypeRaw.trim()\n\n      offset += 28\n\n      const textLen = subChunkSize - 20\n      const utf8Decoder = new TextDecoder('utf-8')\n      const text = utf8Decoder.decode(\n        new Uint8Array(buffer.buffer, buffer.byteOffset + offset, textLen - 1),\n      ) // -1 to remove the null character at the end\n\n      offset += textLen\n      offset += textLen % 2\n\n      const typeMapping = {\n        grph: 'graph',\n        phon: 'phon',\n      }\n      let mappedType = typeMapping[charType]\n\n      timestamps[`${mappedType}_chars`].push(text)\n      timestamps[`${mappedType}_times`].push([\n        cuePoints[cueIdx] / sampleRate,\n        (cuePoints[cueIdx] + nSamples) / sampleRate,\n      ])\n    }\n\n    return {\n      timestamps: timestamps,\n      offset,\n    }\n  } else {\n    return {\n      timestamps: null,\n    }\n  }\n}\n","import UtilV2, {\n  ErrorResponseV2,\n  PaginationResponseV2,\n  ReadResponseV2,\n  WriteResponseV2,\n} from './util'\nimport { DEFAULT_BUFFER_SIZE, StreamDecoder } from './StreamDecoder'\n\nexport interface Clip {\n  uuid: string\n  title: string\n  body: string\n  voice_uuid: string\n  is_public: boolean\n  is_archived: boolean\n  timestamps?: any\n  audio_src?: string\n  raw_audio?: any\n  created_at: Date\n  updated_at: Date\n}\n\ninterface ClipInput {\n  title?: string\n  body: string\n  voice_uuid: string\n  is_public: boolean\n  is_archived: boolean\n  sample_rate?: 16000 | 22050 | 44100\n  output_format?: 'wav' | 'mp3'\n  precision?: 'PCM_16' | 'PCM_32'\n  include_timestamps?: boolean\n}\n\nexport interface SyncClipInput extends ClipInput {\n  raw?: boolean\n}\n\nexport interface AsyncClipInput extends ClipInput {\n  callback_uri: string\n}\n\nexport interface DirectClipInput {\n  voice_uuid: string\n  project_uuid: string\n  title?: string\n  data: string\n  precision?: 'MULAW' | 'PCM_16' | 'PCM_24' | 'PCM_32'\n  output_format?: 'wav' | 'mp3'\n}\n\nexport interface DirectClip {\n  success: true\n  audio_content: string\n  audio_timestamps: {\n    graph_chars: string[]\n    graph_times: [number, number][]\n    phon_chars: string[]\n    phon_times: [number, number][]\n  }\n  duration: number\n  synth_duration: number\n  output_format: 'wav' | 'mp3'\n  sample_rate: number\n  issues: string[]\n}\n\nexport interface DirectClipError {\n  success: false\n  issues?: string[]\n  error_name: string\n  error_params: unknown\n  feedback_uuid: string\n  message: string\n}\n\nexport interface StreamInput {\n  data: string\n  project_uuid: string\n  voice_uuid: string\n  sample_rate?: 8000 | 16000 | 22050 | 44100 | 32000\n  precision?: 'MULAW' | 'PCM_16' | 'PCM_32'\n}\n\nexport interface StreamConfig {\n  bufferSize?: number\n  ignoreWavHeader?: boolean\n  getTimeStamps?: boolean\n}\n\nconst create = async (projectUuid: string, clipInput: ClipInput) => {\n  try {\n    const response = await UtilV2.post(\n      `projects/${projectUuid}/clips`,\n      clipInput,\n    )\n    let json = await response.json()\n    if (json.success) {\n      json = {\n        ...json,\n        item: {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        },\n      }\n    }\n    return json\n  } catch (e) {\n    return UtilV2.errorResponse(e)\n  }\n}\n\nexport default {\n  all: async (\n    projectUuid: string,\n    page: number,\n    pageSize: number,\n  ): Promise<PaginationResponseV2<Clip> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `projects/${projectUuid}/clips?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      const json = await response.json()\n      if (json.success)\n        json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    projectUuid: string,\n    uuid: string,\n  ): Promise<ReadResponseV2<Clip> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(`projects/${projectUuid}/clips/${uuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  createAsync: async (\n    projectUuid: string,\n    clipInput: AsyncClipInput,\n  ): Promise<WriteResponseV2<Clip> | ErrorResponseV2> => {\n    return create(projectUuid, clipInput)\n  },\n\n  createSync: async (\n    projectUuid: string,\n    clipInput: SyncClipInput,\n  ): Promise<WriteResponseV2<Clip> | ErrorResponseV2> => {\n    return create(projectUuid, clipInput)\n  },\n\n  createDirect: async (\n    clipInput: DirectClipInput,\n  ): Promise<DirectClip | DirectClipError | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post('synthesize', clipInput, true)\n      let json = await response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  stream: async function* (\n    streamInput: StreamInput,\n    streamConfig?: StreamConfig,\n  ): AsyncGenerator {\n    const defaultStreamConfig = {\n      bufferSize: DEFAULT_BUFFER_SIZE,\n      ignoreWavHeader: false,\n      getTimeStamps: false,\n    }\n\n    const getTimeStamps =\n      streamConfig?.getTimeStamps || defaultStreamConfig.getTimeStamps\n    const bufferSize =\n      streamConfig?.bufferSize || defaultStreamConfig.bufferSize\n    const ignoreWavHeader =\n      streamConfig?.ignoreWavHeader || defaultStreamConfig.ignoreWavHeader\n\n    try {\n      const response = await UtilV2.post(\n        'stream',\n        {\n          ...streamInput,\n          wav_encoded_timestamps: getTimeStamps,\n        },\n        true,\n      )\n\n      // check for error response\n      if (!response.ok || !response.body) {\n        const isJson = response.headers\n          .get('content-type')\n          ?.includes('application/json')\n        const data = isJson ? await response.json() : null\n        const error = (data && data.message) || response.status\n        throw Error(error)\n      }\n\n      const streamDecoder = new StreamDecoder(\n        bufferSize,\n        ignoreWavHeader,\n        getTimeStamps,\n      )\n      streamDecoder.reset()\n\n      const reader = response.body.getReader()\n\n      // Iterate over the stream and start decoding, and returning data\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read()\n          if (done) break\n\n          streamDecoder.decodeChunk(value)\n          const buffer = streamDecoder.flushBuffer()\n          if (buffer !== null) {\n            yield {\n              data: buffer,\n              timestamps: streamDecoder.getTimestamps(),\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock()\n      }\n\n      // Keep draining the buffer until the buffer.length < bufferSize or buffer.length == 0\n      let buffer = streamDecoder.flushBuffer()\n      while (buffer !== null) {\n        const buffToReturn = new Uint8Array(buffer)\n        buffer = streamDecoder.flushBuffer()\n        yield {\n          data: buffToReturn,\n          timestamps: streamDecoder.getTimestamps(),\n        }\n      }\n\n      // Drain any leftover content in the buffer, buffer.length will always be less than bufferSize here\n      buffer = streamDecoder.flushBuffer(true)\n      if (buffer !== null)\n        yield {\n          data: buffer,\n          timestamps: streamDecoder.getTimestamps(),\n        }\n    } catch (e) {\n      // If an error occurs and the catch block is executed, the function will return a plain object (UtilV2.errorResponse(e)).\n      // This will cause the function to not return an async iterable, leading to an error, so we need to throw the error\n      throw e\n    }\n  },\n\n  updateAsync: async (\n    projectUuid: string,\n    uuid: string,\n    clipInput: AsyncClipInput,\n  ) => {\n    try {\n      const response = await UtilV2.put(\n        `projects/${projectUuid}/clips/${uuid}`,\n        clipInput,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (projectUuid: string, uuid: string) => {\n    try {\n      const response = await UtilV2.delete(\n        `projects/${projectUuid}/clips/${uuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import fetch from 'isomorphic-fetch'\nimport FormData from 'isomorphic-form-data'\nimport { context } from '../context'\nimport UtilV2, {\n  ErrorResponseV2,\n  PaginationResponseV2,\n  UpdateResponseV2,\n  DeleteResponseV2,\n  ReadResponseV2,\n  WriteResponseV2,\n} from './util'\n\nexport interface Recording {\n  uuid: string\n  name: string\n  text: string\n  emotion: string\n  is_active: boolean\n  audio_src: string\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface RecordingInput {\n  name: string\n  text: string\n  emotion: string\n  is_active: boolean\n}\n\nexport default {\n  all: async (\n    voiceUuid: string,\n    page: number,\n    pageSize: number,\n  ): Promise<PaginationResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `voices/${voiceUuid}/recordings?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      const json = await response.json()\n      if (json.success)\n        json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    voiceUuid: string,\n    uuid: string,\n  ): Promise<ReadResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `voices/${voiceUuid}/recordings/${uuid}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  create: async (\n    voiceUuid: string,\n    recordingInput: RecordingInput,\n    buffer: Buffer,\n    fileSizeInBytes: number,\n  ): Promise<WriteResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const formData = new FormData()\n      formData.append('name', recordingInput.name)\n      formData.append('text', recordingInput.text)\n      formData.append('emotion', recordingInput.emotion)\n      formData.append('is_active', recordingInput.is_active ? 'true' : 'false')\n      formData.append('file', buffer, { knownLength: fileSizeInBytes })\n\n      const response = await fetch(\n        context.endpoint('v2', `voices/${voiceUuid}/recordings`),\n        {\n          method: 'POST',\n          headers: {\n            Authorization: context.headers().Authorization,\n            'Content-Type': 'multipart/form-data',\n            ...(formData.getHeaders ? formData.getHeaders() : {}),\n          },\n          body: formData,\n        },\n      )\n\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  update: async (\n    voiceUuid: string,\n    uuid: string,\n    recordingInput: RecordingInput,\n  ): Promise<UpdateResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.put(\n        `voices/${voiceUuid}/recordings/${uuid}`,\n        recordingInput,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (\n    voiceUuid: string,\n    uuid: string,\n  ): Promise<DeleteResponseV2 | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.delete(\n        `voices/${voiceUuid}/recordings/${uuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import UtilV2, {\n  DeleteResponseV2,\n  ErrorResponseV2,\n  PaginationResponseV2,\n  ReadResponseV2,\n  UpdateResponseV2,\n  WriteResponseV2,\n} from './util'\n\nexport interface Voice {\n  uuid: string\n  name: string\n  status: string\n  default_language: string\n  supported_languages: string[]\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface VoiceInput {\n  name: string\n  dataset_url?: string\n  callback_uri?: string\n  consent?: string\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize: number,\n  ): Promise<PaginationResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `voices?page=${page}${pageSize ? `&page_size=${pageSize}` : ''}`,\n      )\n      const json = await response.json()\n      if (json.success)\n        json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    uuid: string,\n  ): Promise<ReadResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(`voices/${uuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  create: async (\n    voiceInput: VoiceInput,\n  ): Promise<WriteResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post('voices', voiceInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  update: async (\n    uuid: string,\n    voiceInput: VoiceInput,\n  ): Promise<UpdateResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.put(`voices/${uuid}`, voiceInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (\n    uuid: string,\n  ): Promise<DeleteResponseV2 | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.delete(`voices/${uuid}`)\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  build: async (\n    uuid: string,\n  ): Promise<{ success: boolean; message?: string } | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post(`voices/${uuid}/build`)\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import UtilV2, { ErrorResponseV2, PaginationResponseV2 } from './util'\n\nexport interface Batch {\n  uuid: string\n  body: Array<[string, string]>\n  voice_uuid: string\n  callback_uri?: string\n  total_count: number\n  completed_count: number\n  failed_count: number\n  created_at: Date\n  updated_at: Date\n}\n\nexport default {\n  all: async (\n    projectUuid: string,\n    page: number,\n    pageSize?: number,\n  ): Promise<PaginationResponseV2<Batch> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `projects/${projectUuid}/batch?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item: Batch) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  create: async (\n    projectUuid: string,\n    voiceUuid: string,\n    body: string[] | Array<[string, string]>,\n    batchInputConfig: {\n      callbackUri: string\n      precision: 'PCM_32' | 'PCM_16' | 'MULAW'\n      sampleRate: 8000 | 16000 | 22050 | 44100\n      outputFormat: 'wav' | 'mp3'\n    },\n  ) => {\n    try {\n      const options = {\n        body: body,\n        voice_uuid: voiceUuid,\n        sample_rate: batchInputConfig?.sampleRate,\n        output_format: batchInputConfig?.outputFormat,\n        precision: batchInputConfig?.precision,\n      }\n      if (batchInputConfig?.callbackUri) {\n        options['callback_uri'] = batchInputConfig?.callbackUri\n      }\n      const response = await UtilV2.post(\n        `/projects/${projectUuid}/batch`,\n        options,\n      )\n\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  get: async (projectUuid: string, batchUuid: string) => {\n    try {\n      const response = await UtilV2.get(\n        `projects/${projectUuid}/batch/${batchUuid}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n  delete: async (projectUuid: string, batchUuid: string) => {\n    try {\n      const response = await UtilV2.delete(\n        `projects/${projectUuid}/batch/${batchUuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import UtilV2, { ErrorResponseV2, PaginationResponseV2 } from './util'\n\nexport interface Phoneme {\n  uuid: string\n  alphabet: string\n  word: string\n  phonetic_transcription: string\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface AllPhonemeResponse {\n  success: boolean\n  page: number\n  num_pages: number\n  page_size: number\n  items: Phoneme[]\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize?: number,\n  ): Promise<PaginationResponseV2<AllPhonemeResponse> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `phonemes?page=${page}${pageSize ? `&page_size=${pageSize}` : ''}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item: Phoneme) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  create: async (word: string, phonetic_transcription: string) => {\n    try {\n      const response = await UtilV2.post('phonemes', {\n        word,\n        phonetic_transcription,\n      })\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  get: async (phonemeUuid: string) => {\n    try {\n      const response = await UtilV2.get(`phonemes/${phonemeUuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  delete: async (phoneme_uuid: string) => {\n    try {\n      const response = await UtilV2.delete(`phonemes/${phoneme_uuid}`)\n      const json = response.json()\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n}\n","import UtilV2, { ErrorResponseV2, PaginationResponseV2 } from './util'\n\nexport interface TermSubstitution {\n  uuid: string\n  original_text: string\n  replacement_text: string\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface AllTermSubstitutionResponse {\n  success: boolean\n  page: number\n  num_pages: number\n  page_size: number\n  items: TermSubstitution[]\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize?: number,\n  ): Promise<\n    PaginationResponseV2<AllTermSubstitutionResponse> | ErrorResponseV2\n  > => {\n    try {\n      const response = await UtilV2.get(\n        `term_substitutions?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item: TermSubstitution) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  create: async (original_text: string, replacement_text: string) => {\n    try {\n      const response = await UtilV2.post('term_substitutions', {\n        original_text,\n        replacement_text,\n      })\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  get: async (termSubstitutionUuid: string) => {\n    try {\n      const response = await UtilV2.get(\n        `term_substitutions/${termSubstitutionUuid}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  delete: async (termSubstitutionUuid: string) => {\n    try {\n      const response = await UtilV2.delete(\n        `term_substitutions/${termSubstitutionUuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n}\n","import { context } from './context'\nimport ProjectsV2 from './v2/projects'\nimport ClipsV2 from './v2/clips'\nimport RecordingsV2 from './v2/recordings'\nimport VoicesV2 from './v2/voices'\nimport BatchV2 from './v2/batch'\nimport PhonemesV2 from './v2/phonemes'\nimport TermSubstitutionsV2 from './v2/termSubstitutions'\n\nexport const Resemble = {\n  setApiKey: context.setApiKey,\n  setBaseUrl: context.setBaseUrl,\n  setSynthesisUrl: context.setSynthesisUrl,\n\n  v2: {\n    projects: {\n      all: ProjectsV2.all,\n      create: ProjectsV2.create,\n      update: ProjectsV2.update,\n      get: ProjectsV2.get,\n      delete: ProjectsV2.destroy,\n    },\n    clips: {\n      all: ClipsV2.all,\n      createSync: ClipsV2.createSync,\n      createAsync: ClipsV2.createAsync,\n      createDirect: ClipsV2.createDirect,\n      updateAsync: ClipsV2.updateAsync,\n      stream: ClipsV2.stream,\n      get: ClipsV2.get,\n      delete: ClipsV2.destroy,\n    },\n    voices: {\n      all: VoicesV2.all,\n      create: VoicesV2.create,\n      update: VoicesV2.update,\n      build: VoicesV2.build,\n      get: VoicesV2.get,\n      delete: VoicesV2.destroy,\n    },\n    recordings: {\n      all: RecordingsV2.all,\n      get: RecordingsV2.get,\n      create: RecordingsV2.create,\n      update: RecordingsV2.update,\n      delete: RecordingsV2.destroy,\n    },\n    batch: {\n      all: BatchV2.all,\n      get: BatchV2.get,\n      create: BatchV2.create,\n      delete: BatchV2.delete,\n    },\n    phonemes: {\n      all: PhonemesV2.all,\n      create: PhonemesV2.create,\n      get: PhonemesV2.get,\n      delete: PhonemesV2.delete,\n    },\n    termSubstitutions: {\n      all: TermSubstitutionsV2.all,\n      get: TermSubstitutionsV2.get,\n      create: TermSubstitutionsV2.create,\n      delete: TermSubstitutionsV2.delete,\n    },\n  },\n}\n"],"names":["apiKey","baseUrl","synthesisServerHeaders","Authorization","context","headers","setBaseUrl","url","endsWith","setApiKey","key","setSynthesisUrl","synthesisServerUrl","endpoint","version","startsWith","substring","ending","synServerUrl","UtilV2","path","useSynthesisServer","fetch","method","data","body","JSON","stringify","e","success","message","arrays","totalLength","length","reduce","accumulator","currentValue","returnValue","Uint8Array","offset","array","set","ProjectsV2","all","page","pageSize","Promise","resolve","_catch","then","response","json","items","map","item","_extends","created_at","Date","updated_at","reject","get","uuid","create","projectInput","update","destroy","STREAMING_WAV_HEADER_BUFFER_LEN","StreamDecoder","bufferSize","ignoreWavHeader","timeStampsProcessingRequired","Error","this","chunks","headerBuffer","processTimeStamps","timeStampsBuffer","allTimestampsProcessed","timeStamps","prototype","setBufferSize","size","setIgnoreWavHeader","val","decodeChunk","chunk","push","tempBuf","concatUint8Arrays","slice","tempDataBuffer","obj","extractTimestampsFromBuffer","timestamps","_tempBuf3","_tempDataBuffer2","_tempDataBuffer3","flushBuffer","force","returnBuffer","leftoverBuffer","reset","getTimestamps","buffer","dataView","DataView","byteOffset","byteLength","sampleRate","getUint16","getUint32","chunkType","textDecoder","decode","graph_chars","graph_times","phon_chars","phon_times","_ref2","remSize","nCuePoints","cp","idx","cuePoint","cuePoints","listEndPoint","subChunkSize","nSamples","charType","trim","textLen","text","TextDecoder","mappedType","grph","phon","cueIdx","_ref","projectUuid","clipInput","createAsync","createSync","createDirect","stream","_regeneratorRuntime","mark","streamInput","streamConfig","defaultStreamConfig","getTimeStamps","_response$headers$get","streamDecoder","reader","_yield$_awaitAsyncGen","value","_buffer","buffToReturn","wrap","_context","prev","next","wav_encoded_timestamps","sent","ok","includes","_awaitAsyncGenerator","error","status","getReader","read","done","releaseLock","t1","stop","_callee","updateAsync","RecordingsV2","voiceUuid","recordingInput","fileSizeInBytes","formData","FormData","append","name","emotion","is_active","knownLength","getHeaders","VoicesV2","voiceInput","build","batchInputConfig","options","voice_uuid","sample_rate","output_format","outputFormat","precision","callbackUri","batchUuid","delete","PhonemesV2","word","phonetic_transcription","phonemeUuid","phoneme_uuid","TermSubstitutionsV2","original_text","replacement_text","termSubstitutionUuid","v2","projects","clips","ClipsV2","voices","recordings","batch","BatchV2","phonemes","termSubstitutions"],"mappings":"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"}