{"version":3,"file":"resemble.module.js","sources":["../src/context.ts","../src/v2/util.ts","../src/v2/projects.ts","../src/v2/StreamDecoder.ts","../src/v2/clips.ts","../src/v2/recordings.ts","../src/v2/voices.ts","../src/v2/batch.ts","../src/v2/phonemes.ts","../src/v2/termSubstitutions.ts","../src/resemble.ts"],"sourcesContent":["let apiKey: string | undefined = ''\nlet baseUrl: string | undefined = 'https://app.resemble.ai/api/'\nlet synthesisServerUrl: string | undefined = ''\n\nconst synthesisServerHeaders: Record<string, string> = {\n  'Content-Type': 'application/json',\n  'x-access-token': apiKey,\n}\n\nconst headers: Record<string, string> = {\n  'Content-Type': 'application/json',\n  Authorization: `Token token=${apiKey}`,\n}\n\nexport const context = {\n  headers: () => headers,\n  synthesisServerHeaders: () => synthesisServerHeaders,\n\n  setBaseUrl: (url: string) => {\n    baseUrl = url\n\n    if (!url.endsWith('/')) {\n      baseUrl += '/'\n    }\n  },\n\n  setApiKey: (key: string) => {\n    apiKey = key\n    headers['Authorization'] = `Token token=${key}`\n    synthesisServerHeaders['x-access-token'] = key\n  },\n\n  setSynthesisUrl: (url: string) => {\n    synthesisServerUrl = url\n\n    if (!url.endsWith('/')) {\n      synthesisServerUrl += '/'\n    }\n  },\n\n  endpoint: (version: string, endpoint: string): string => {\n    let ending = endpoint.startsWith('/') ? endpoint.substring(1) : endpoint\n    return `${baseUrl}${version}/${ending}`\n  },\n\n  synServerUrl: (endpoint) => {\n    let ending = endpoint.startsWith('/') ? endpoint.substring(1) : endpoint\n    const url = `${synthesisServerUrl}${ending}`\n    return url\n  },\n}\n","import { context } from '../context'\n\nexport interface ReadResponseV2<T> {\n  success: boolean\n  message?: string\n  item: T | null\n}\n\nexport interface WriteResponseV2<T> {\n  success: boolean\n  message?: string\n  /* The item is returned when the write operation succeeds */\n  item?: T\n}\n\nexport interface UpdateResponseV2<T> {\n  success: boolean\n  message?: string\n  /* The item is returned when the update operation succeeds */\n  item?: T\n}\n\nexport interface DeleteResponseV2 {\n  success: boolean\n  message?: string\n}\n\nexport interface PaginationResponseV2<T> {\n  success: boolean\n  message?: string\n  page: number\n  num_pages: number\n  page_size: number\n  items: T[]\n}\n\nexport interface ErrorResponseV2 {\n  success: false\n  message: string\n}\n\nexport default {\n  get: (path: string, useSynthesisServer: boolean = false) => {\n    return fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'GET',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n      },\n    )\n  },\n  post: (\n    path: string,\n    data: Record<string, any> = {},\n    useSynthesisServer: boolean = false,\n  ) =>\n    fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'POST',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n        body: JSON.stringify(data),\n      },\n    ),\n  put: (\n    path: string,\n    data: Record<string, any> = {},\n    useSynthesisServer: boolean = false,\n  ) =>\n    fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'PUT',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n        body: JSON.stringify(data),\n      },\n    ),\n  delete: (path: string, useSynthesisServer: boolean = false) =>\n    fetch(\n      useSynthesisServer\n        ? context.synServerUrl(path)\n        : context.endpoint('v2', path),\n      {\n        method: 'DELETE',\n        headers: useSynthesisServer\n          ? context.synthesisServerHeaders()\n          : context.headers(),\n      },\n    ),\n\n  errorResponse: (e: any): ErrorResponseV2 => ({\n    success: false,\n    message: `Library error: ${e}`,\n  }),\n}\n\n// https://github.com/sindresorhus/uint8array-extras\n\nexport function concatUint8Arrays(arrays: Uint8Array[], totalLength?: number) {\n  if (arrays.length === 0) {\n    return new Uint8Array(0)\n  }\n\n  totalLength ??= arrays.reduce(\n    (accumulator, currentValue) => accumulator + currentValue.length,\n    0,\n  )\n\n  const returnValue = new Uint8Array(totalLength)\n\n  let offset = 0\n  for (const array of arrays) {\n    returnValue.set(array, offset)\n    offset += array.length\n  }\n\n  return returnValue\n}\n","import UtilV2, {\n  DeleteResponseV2,\n  ErrorResponseV2,\n  PaginationResponseV2,\n  ReadResponseV2,\n  UpdateResponseV2,\n  WriteResponseV2,\n} from './util'\n\nexport interface Project {\n  uuid: string\n  name: string\n  description: string\n  is_public: boolean\n  is_collaborative: boolean\n  is_archived: boolean\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface ProjectInput {\n  name: string\n  description: string\n  is_public: boolean\n  is_collaborative: boolean\n  is_archived: boolean\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize?: number,\n  ): Promise<PaginationResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `projects?page=${page}${pageSize ? `&page_size=${pageSize}` : ''}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    uuid: string,\n  ): Promise<ReadResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(`projects/${uuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  create: async (\n    projectInput: ProjectInput,\n  ): Promise<WriteResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post('projects', projectInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  update: async (\n    uuid: string,\n    projectInput: ProjectInput,\n  ): Promise<UpdateResponseV2<Project> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.put(`projects/${uuid}`, projectInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (\n    uuid: string,\n  ): Promise<DeleteResponseV2 | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.delete(`projects/${uuid}`)\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import { concatUint8Arrays } from './util'\n\nexport const DEFAULT_BUFFER_SIZE = 4 * 1024\nexport const STREAMING_WAV_HEADER_BUFFER_LEN = 36\n\nexport const StreamDecoder = function (\n  bufferSize = DEFAULT_BUFFER_SIZE,\n  ignoreWavHeader = true,\n  timeStampsProcessingRequired = false,\n) {\n  if (bufferSize < 2) throw new Error('Buffer size cannot be less than 2')\n  if (bufferSize % 2 !== 0)\n    throw new Error('Buffer size must be evenly divisible by 2.')\n  this.bufferSize = bufferSize\n  this.ignoreWavHeader = ignoreWavHeader\n  this.chunks = []\n  this.headerBuffer = new Uint8Array()\n\n  this.processTimeStamps = timeStampsProcessingRequired\n  this.timeStampsBuffer = []\n  this.allTimestampsProcessed = false\n  this.timeStamps = {}\n}\n\nStreamDecoder.prototype.setBufferSize = function (size) {\n  if (size < 2) throw new Error('Buffer size cannot be less than 2')\n  if (size % 2 !== 0)\n    throw new Error('Buffer size must be evenly divisible by 2.')\n  this.bufferSize = size\n}\n\nStreamDecoder.prototype.setIgnoreWavHeader = function (val) {\n  this.ignoreWavHeader = val\n}\n\nStreamDecoder.prototype.decodeChunk = function (chunk: Uint8Array) {\n  // 1. assume user wants headers. no timestamps have been requested, we can store the chunks as they come\n  this.chunks.push(chunk)\n\n  // 2. user does not need headers and timestamps are also not present, so we ignore the 36 bytes (wav header size) and return the rest\n  if (\n    this.headerBuffer.length < STREAMING_WAV_HEADER_BUFFER_LEN && // check if header has been processed\n    this.ignoreWavHeader && // Check if header should be ignored\n    !this.processTimeStamps\n  ) {\n    const tempBuf = concatUint8Arrays(this.chunks)\n    if (tempBuf.length >= STREAMING_WAV_HEADER_BUFFER_LEN) {\n      this.headerBuffer = tempBuf.slice(0, STREAMING_WAV_HEADER_BUFFER_LEN) // Extract header, for next set of chunks to ignore\n      const tempDataBuffer = tempBuf.slice(STREAMING_WAV_HEADER_BUFFER_LEN) // Extract data\n\n      this.chunks = []\n      this.chunks.push(tempDataBuffer) // set the chunks with the data\n    }\n  }\n\n  // timestamps are present, keep storing them untill all timestamps have been processed\n  if (this.processTimeStamps && !this.allTimestampsProcessed) {\n    this.timeStampsBuffer.push(chunk)\n  }\n\n  // 3. user wants timestamps and headers: process the timestamps, preserve the 36 bytes and discard the timestamp bytes\n  if (!this.ignoreWavHeader && this.processTimeStamps) {\n    if (!this.allTimestampsProcessed) {\n      const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n\n      const obj = this.extractTimestampsFromBuffer(tempBuf)\n\n      // we ran past the buffer length, just preserve the header for now\n      if (!obj.timestamps) {\n        // no wav headers yet, obtain it:\n        if (this.headerBuffer.length < STREAMING_WAV_HEADER_BUFFER_LEN) {\n          const tempBuf = concatUint8Arrays(this.chunks)\n          if (tempBuf.length >= STREAMING_WAV_HEADER_BUFFER_LEN) {\n            this.headerBuffer = tempBuf.slice(\n              0,\n              STREAMING_WAV_HEADER_BUFFER_LEN,\n            )\n\n            this.chunks = []\n            this.chunks.push(this.headerBuffer)\n          }\n        } else {\n          // since header exists and we don't have timestamps yet, it means we can reset the chunk to only contain the header\n          this.chunks = []\n          this.chunks.push(this.headerBuffer)\n        }\n      }\n\n      // timestamps are present, process them\n      if (obj.timestamps && obj.timestamps !== null) {\n        if (this.headerBuffer.length < STREAMING_WAV_HEADER_BUFFER_LEN) {\n          // header not processed yet, process it and discard the timestamps bytes. also process the data bytes if any in current chunk\n          const tempBuf = concatUint8Arrays(this.chunks)\n          if (tempBuf.length >= STREAMING_WAV_HEADER_BUFFER_LEN) {\n            this.headerBuffer = tempBuf.slice(\n              0,\n              STREAMING_WAV_HEADER_BUFFER_LEN,\n            )\n\n            this.chunks = []\n            const tempDataBuffer = tempBuf.slice(obj.offset)\n            this.chunks.push(this.headerBuffer)\n            this.chunks.push(tempDataBuffer)\n          }\n        } else {\n          // header has already been processed, discard the timestamps bytes and preserve wav header and the data bytes if any\n          const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n          const tempDataBuffer = tempBuf.slice(obj.offset)\n\n          this.chunks = []\n          this.chunks.push(this.headerBuffer)\n          this.chunks.push(tempDataBuffer)\n        }\n\n        // mark all timestamps as processed\n        this.timeStamps = obj.timestamps\n        this.allTimestampsProcessed = true\n        this.timeStampsBuffer = []\n      }\n    }\n  }\n\n  // 4. timestamps are present and have been requested but no headers are wanted\n  if (this.ignoreWavHeader && this.processTimeStamps) {\n    if (!this.allTimestampsProcessed) {\n      const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n      const obj = this.extractTimestampsFromBuffer(tempBuf)\n\n      if (!obj.timestamps && obj.offset) {\n        // we haven't reached the data section yet, discard evrything\n        this.chunks = []\n      }\n\n      if (obj.timestamps && obj.timestamps !== null) {\n        this.timeStamps = obj.timestamps\n        this.allTimestampsProcessed = true\n        const tempBuf = concatUint8Arrays(this.timeStampsBuffer)\n        const tempDataBuffer = tempBuf.slice(obj.offset)\n        this.chunks = []\n        this.chunks.push(tempDataBuffer)\n      }\n    }\n  }\n}\n\nStreamDecoder.prototype.flushBuffer = function (force = false) {\n  const tempBuf = concatUint8Arrays(this.chunks)\n  if (force && tempBuf.length > 0) {\n    this.chunks = []\n    return tempBuf\n  }\n  if (tempBuf.length >= this.bufferSize) {\n    const returnBuffer = tempBuf.slice(0, this.bufferSize)\n    const leftoverBuffer = tempBuf.slice(this.bufferSize)\n    this.chunks = []\n    this.chunks.push(leftoverBuffer)\n    return returnBuffer\n  }\n  return null\n}\n\nStreamDecoder.prototype.reset = function () {\n  this.chunks = []\n  this.headerBuffer = new Uint8Array()\n}\n\nStreamDecoder.prototype.getTimestamps = function () {\n  if (this.processTimeStamps && this.allTimestampsProcessed) {\n    return this.timeStamps\n  }\n  return null\n}\n\nStreamDecoder.prototype.extractTimestampsFromBuffer = function (\n  buffer: Uint8Array,\n) {\n  let offset = 0\n  offset += 4 // Skip RIFF ID\n\n  offset += 4 // skip remaining file size\n  offset += 14 // skp RIFF type (WAVE), format chunk id, chunk data size, and compression code\n\n  const dataView = new DataView(\n    buffer.buffer,\n    buffer.byteOffset,\n    buffer.byteLength,\n  )\n\n  let [nChannels, sampleRate] = [\n    dataView.getUint16(offset, true), // read number of channels\n    dataView.getUint32(offset + 2, true), // and sample rate\n  ]\n  offset += 14 // skip byte rate, block align and bits per sample at this point we have covered the Header & Format chunks: https://docs.app.resemble.ai/docs/resource_clip/stream#header--format-chunks\n\n  const textDecoder = new TextDecoder('ascii')\n\n  let chunkType = textDecoder.decode(\n    new Uint8Array(buffer.buffer, buffer.byteOffset + offset, 4),\n  ) // now we are at Timestamps (cue, list & ltxt chunks): https://docs.app.resemble.ai/docs/resource_clip/stream#timestamps-cue-list--ltxt-chunks\n\n  offset += 4\n  const timestamps = {\n    graph_chars: [],\n    graph_times: [],\n    phon_chars: [],\n    phon_times: [],\n  }\n\n  if (chunkType === 'cue ') {\n    let [remSize, nCuePoints] = [\n      dataView.getUint32(offset, true), // Remaining size of the cue chunk\n      dataView.getUint32(offset + 4, true), // Number of remaining cue points\n    ]\n    offset += 8 // skip to the first cue point\n    let endPoint = offset + remSize - 4 // we subtract 4 to account for the \"n_cue_points\" field size\n\n    let cuePoints = {}\n\n    // start from the first cue point and read all cue points\n    // each cue point is 24 bytes long\n\n    if (endPoint > buffer.length) {\n      return { timestamps: null, offset }\n    }\n    for (let cp = 1; cp <= nCuePoints; cp++) {\n      const idx = dataView.getUint32(offset, true)\n      const cuePoint = dataView.getUint32(offset + 20, true)\n      cuePoints[idx] = cuePoint\n      offset += 24\n    }\n\n    // now the offset is at the beginning of the LIST chunk, remember we are processing in the little-endian order\n    chunkType = textDecoder.decode(\n      new Uint8Array(buffer.buffer, buffer.byteOffset + offset, 4),\n    ) // read the LIST chunk type\n    remSize = dataView.getUint32(offset + 4, true)\n    offset += 12 // arrive at the start of first LTXT chunk\n\n    let listEndPoint = offset + remSize - 4 // we subtract 4 to account for the \"rem size\" field\n\n    if (listEndPoint > buffer.length) {\n      return { timestamps: null, offset }\n    }\n\n    // start from the first LTXT chunk and read all LTXT chunks\n    while (offset < listEndPoint) {\n      const subChunkSize = dataView.getUint32(offset + 4, true) // Remaining size of this ltxt chunk after this read\n      const cueIdx = dataView.getUint32(offset + 8, true)\n      const nSamples = dataView.getUint32(offset + 12, true)\n      let charTypeRaw = textDecoder.decode(\n        new Uint8Array(buffer.buffer, buffer.byteOffset + offset + 16, 4),\n      ) // \"grph\" OR \"phon\"\n      let charType = charTypeRaw.trim()\n\n      offset += 28\n\n      const textLen = subChunkSize - 20\n      const utf8Decoder = new TextDecoder('utf-8')\n      const text = utf8Decoder.decode(\n        new Uint8Array(buffer.buffer, buffer.byteOffset + offset, textLen - 1),\n      ) // -1 to remove the null character at the end\n\n      offset += textLen\n      offset += textLen % 2\n\n      const typeMapping = {\n        grph: 'graph',\n        phon: 'phon',\n      }\n      let mappedType = typeMapping[charType]\n\n      timestamps[`${mappedType}_chars`].push(text)\n      timestamps[`${mappedType}_times`].push([\n        cuePoints[cueIdx] / sampleRate,\n        (cuePoints[cueIdx] + nSamples) / sampleRate,\n      ])\n    }\n\n    return {\n      timestamps: timestamps,\n      offset,\n    }\n  } else {\n    return {\n      timestamps: null,\n    }\n  }\n}\n","import UtilV2, {\n  ErrorResponseV2,\n  PaginationResponseV2,\n  ReadResponseV2,\n  WriteResponseV2,\n} from './util'\nimport { DEFAULT_BUFFER_SIZE, StreamDecoder } from './StreamDecoder'\n\nexport interface Clip {\n  uuid: string\n  title: string\n  body: string\n  voice_uuid: string\n  is_public: boolean\n  is_archived: boolean\n  timestamps?: any\n  audio_src?: string\n  raw_audio?: any\n  created_at: Date\n  updated_at: Date\n}\n\ninterface ClipInput {\n  title?: string\n  body: string\n  voice_uuid: string\n  is_public: boolean\n  is_archived: boolean\n  sample_rate?: 16000 | 22050 | 44100\n  output_format?: 'wav' | 'mp3'\n  precision?: 'PCM_16' | 'PCM_32'\n  include_timestamps?: boolean\n}\n\nexport interface SyncClipInput extends ClipInput {\n  raw?: boolean\n}\n\nexport interface AsyncClipInput extends ClipInput {\n  callback_uri: string\n}\n\nexport interface DirectClipInput {\n  voice_uuid: string\n  project_uuid: string\n  title?: string\n  data: string\n  precision?: 'MULAW' | 'PCM_16' | 'PCM_24' | 'PCM_32'\n  output_format?: 'wav' | 'mp3'\n}\n\nexport interface DirectClip {\n  success: true\n  audio_content: string\n  audio_timestamps: {\n    graph_chars: string[]\n    graph_times: [number, number][]\n    phon_chars: string[]\n    phon_times: [number, number][]\n  }\n  duration: number\n  synth_duration: number\n  output_format: 'wav' | 'mp3'\n  sample_rate: number\n  issues: string[]\n}\n\nexport interface DirectClipError {\n  success: false\n  issues?: string[]\n  error_name: string\n  error_params: unknown\n  feedback_uuid: string\n  message: string\n}\n\nexport interface StreamInput {\n  data: string\n  project_uuid: string\n  voice_uuid: string\n  sample_rate?: 8000 | 16000 | 22050 | 44100 | 32000\n  precision?: 'MULAW' | 'PCM_16' | 'PCM_32'\n}\n\nexport interface StreamConfig {\n  bufferSize?: number\n  ignoreWavHeader?: boolean\n  getTimeStamps?: boolean\n}\n\nconst create = async (projectUuid: string, clipInput: ClipInput) => {\n  try {\n    const response = await UtilV2.post(\n      `projects/${projectUuid}/clips`,\n      clipInput,\n    )\n    let json = await response.json()\n    if (json.success) {\n      json = {\n        ...json,\n        item: {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        },\n      }\n    }\n    return json\n  } catch (e) {\n    return UtilV2.errorResponse(e)\n  }\n}\n\nexport default {\n  all: async (\n    projectUuid: string,\n    page: number,\n    pageSize: number,\n  ): Promise<PaginationResponseV2<Clip> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `projects/${projectUuid}/clips?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      const json = await response.json()\n      if (json.success)\n        json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    projectUuid: string,\n    uuid: string,\n  ): Promise<ReadResponseV2<Clip> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(`projects/${projectUuid}/clips/${uuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  createAsync: async (\n    projectUuid: string,\n    clipInput: AsyncClipInput,\n  ): Promise<WriteResponseV2<Clip> | ErrorResponseV2> => {\n    return create(projectUuid, clipInput)\n  },\n\n  createSync: async (\n    projectUuid: string,\n    clipInput: SyncClipInput,\n  ): Promise<WriteResponseV2<Clip> | ErrorResponseV2> => {\n    return create(projectUuid, clipInput)\n  },\n\n  createDirect: async (\n    clipInput: DirectClipInput,\n  ): Promise<DirectClip | DirectClipError | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post('synthesize', clipInput, true)\n      let json = await response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  stream: async function* (\n    streamInput: StreamInput,\n    streamConfig?: StreamConfig,\n  ): AsyncGenerator {\n    const defaultStreamConfig = {\n      bufferSize: DEFAULT_BUFFER_SIZE,\n      ignoreWavHeader: false,\n      getTimeStamps: false,\n    }\n\n    const getTimeStamps =\n      streamConfig?.getTimeStamps || defaultStreamConfig.getTimeStamps\n    const bufferSize =\n      streamConfig?.bufferSize || defaultStreamConfig.bufferSize\n    const ignoreWavHeader =\n      streamConfig?.ignoreWavHeader || defaultStreamConfig.ignoreWavHeader\n\n    try {\n      const response = await UtilV2.post(\n        'stream',\n        {\n          ...streamInput,\n          wav_encoded_timestamps: getTimeStamps,\n        },\n        true,\n      )\n\n      // check for error response\n      if (!response.ok || !response.body) {\n        const isJson = response.headers\n          .get('content-type')\n          ?.includes('application/json')\n        const data = isJson ? await response.json() : null\n        const error = (data && data.message) || response.status\n        throw Error(error)\n      }\n\n      const streamDecoder = new StreamDecoder(\n        bufferSize,\n        ignoreWavHeader,\n        getTimeStamps,\n      )\n      streamDecoder.reset()\n\n      const reader = response.body.getReader()\n\n      // Iterate over the stream and start decoding, and returning data\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read()\n          if (done) break\n\n          streamDecoder.decodeChunk(value)\n          const buffer = streamDecoder.flushBuffer()\n          if (buffer !== null) {\n            yield {\n              data: buffer,\n              timestamps: streamDecoder.getTimestamps(),\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock()\n      }\n\n      // Keep draining the buffer until the buffer.length < bufferSize or buffer.length == 0\n      let buffer = streamDecoder.flushBuffer()\n      while (buffer !== null) {\n        const buffToReturn = new Uint8Array(buffer)\n        buffer = streamDecoder.flushBuffer()\n        yield {\n          data: buffToReturn,\n          timestamps: streamDecoder.getTimestamps(),\n        }\n      }\n\n      // Drain any leftover content in the buffer, buffer.length will always be less than bufferSize here\n      buffer = streamDecoder.flushBuffer(true)\n      if (buffer !== null)\n        yield {\n          data: buffer,\n          timestamps: streamDecoder.getTimestamps(),\n        }\n    } catch (e) {\n      // If an error occurs and the catch block is executed, the function will return a plain object (UtilV2.errorResponse(e)).\n      // This will cause the function to not return an async iterable, leading to an error, so we need to throw the error\n      throw e\n    }\n  },\n\n  updateAsync: async (\n    projectUuid: string,\n    uuid: string,\n    clipInput: AsyncClipInput,\n  ) => {\n    try {\n      const response = await UtilV2.put(\n        `projects/${projectUuid}/clips/${uuid}`,\n        clipInput,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (projectUuid: string, uuid: string) => {\n    try {\n      const response = await UtilV2.delete(\n        `projects/${projectUuid}/clips/${uuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import fetch from 'isomorphic-fetch'\nimport FormData from 'isomorphic-form-data'\nimport { context } from '../context'\nimport UtilV2, {\n  ErrorResponseV2,\n  PaginationResponseV2,\n  UpdateResponseV2,\n  DeleteResponseV2,\n  ReadResponseV2,\n  WriteResponseV2,\n} from './util'\n\nexport interface Recording {\n  uuid: string\n  name: string\n  text: string\n  emotion: string\n  is_active: boolean\n  audio_src: string\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface RecordingInput {\n  name: string\n  text: string\n  emotion: string\n  is_active: boolean\n}\n\nexport default {\n  all: async (\n    voiceUuid: string,\n    page: number,\n    pageSize: number,\n  ): Promise<PaginationResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `voices/${voiceUuid}/recordings?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      const json = await response.json()\n      if (json.success)\n        json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    voiceUuid: string,\n    uuid: string,\n  ): Promise<ReadResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `voices/${voiceUuid}/recordings/${uuid}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  create: async (\n    voiceUuid: string,\n    recordingInput: RecordingInput,\n    buffer: Buffer,\n    fileSizeInBytes: number,\n  ): Promise<WriteResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const formData = new FormData()\n      formData.append('name', recordingInput.name)\n      formData.append('text', recordingInput.text)\n      formData.append('emotion', recordingInput.emotion)\n      formData.append('is_active', recordingInput.is_active ? 'true' : 'false')\n      formData.append('file', buffer, { knownLength: fileSizeInBytes })\n\n      const response = await fetch(\n        context.endpoint('v2', `voices/${voiceUuid}/recordings`),\n        {\n          method: 'POST',\n          headers: {\n            Authorization: context.headers().Authorization,\n            'Content-Type': 'multipart/form-data',\n            ...(formData.getHeaders ? formData.getHeaders() : {}),\n          },\n          body: formData,\n        },\n      )\n\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  update: async (\n    voiceUuid: string,\n    uuid: string,\n    recordingInput: RecordingInput,\n  ): Promise<UpdateResponseV2<Recording> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.put(\n        `voices/${voiceUuid}/recordings/${uuid}`,\n        recordingInput,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (\n    voiceUuid: string,\n    uuid: string,\n  ): Promise<DeleteResponseV2 | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.delete(\n        `voices/${voiceUuid}/recordings/${uuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import UtilV2, {\n  DeleteResponseV2,\n  ErrorResponseV2,\n  PaginationResponseV2,\n  ReadResponseV2,\n  UpdateResponseV2,\n  WriteResponseV2,\n} from './util'\n\nexport interface Voice {\n  uuid: string\n  name: string\n  status: string\n  default_language: string\n  supported_languages: string[]\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface VoiceInput {\n  name: string\n  dataset_url?: string\n  callback_uri?: string\n  consent?: string\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize: number,\n  ): Promise<PaginationResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `voices?page=${page}${pageSize ? `&page_size=${pageSize}` : ''}`,\n      )\n      const json = await response.json()\n      if (json.success)\n        json.items.map((item) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  get: async (\n    uuid: string,\n  ): Promise<ReadResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(`voices/${uuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  create: async (\n    voiceInput: VoiceInput,\n  ): Promise<WriteResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post('voices', voiceInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  update: async (\n    uuid: string,\n    voiceInput: VoiceInput,\n  ): Promise<UpdateResponseV2<Voice> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.put(`voices/${uuid}`, voiceInput)\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  destroy: async (\n    uuid: string,\n  ): Promise<DeleteResponseV2 | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.delete(`voices/${uuid}`)\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n\n  build: async (\n    uuid: string,\n  ): Promise<{ success: boolean; message?: string } | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.post(`voices/${uuid}/build`)\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import UtilV2, { ErrorResponseV2, PaginationResponseV2 } from './util'\n\nexport interface Batch {\n  uuid: string\n  body: Array<[string, string]>\n  voice_uuid: string\n  callback_uri?: string\n  total_count: number\n  completed_count: number\n  failed_count: number\n  created_at: Date\n  updated_at: Date\n}\n\nexport default {\n  all: async (\n    projectUuid: string,\n    page: number,\n    pageSize?: number,\n  ): Promise<PaginationResponseV2<Batch> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `projects/${projectUuid}/batch?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item: Batch) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  create: async (\n    projectUuid: string,\n    voiceUuid: string,\n    body: string[] | Array<[string, string]>,\n    batchInputConfig: {\n      callbackUri: string\n      precision: 'PCM_32' | 'PCM_16' | 'MULAW'\n      sampleRate: 8000 | 16000 | 22050 | 44100\n      outputFormat: 'wav' | 'mp3'\n    },\n  ) => {\n    try {\n      const options = {\n        body: body,\n        voice_uuid: voiceUuid,\n        sample_rate: batchInputConfig?.sampleRate,\n        output_format: batchInputConfig?.outputFormat,\n        precision: batchInputConfig?.precision,\n      }\n      if (batchInputConfig?.callbackUri) {\n        options['callback_uri'] = batchInputConfig?.callbackUri\n      }\n      const response = await UtilV2.post(\n        `/projects/${projectUuid}/batch`,\n        options,\n      )\n\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  get: async (projectUuid: string, batchUuid: string) => {\n    try {\n      const response = await UtilV2.get(\n        `projects/${projectUuid}/batch/${batchUuid}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json = {\n          ...json,\n          item: {\n            ...json.item,\n            created_at: new Date(json.item.created_at),\n            updated_at: new Date(json.item.updated_at),\n          },\n        }\n      }\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n  delete: async (projectUuid: string, batchUuid: string) => {\n    try {\n      const response = await UtilV2.delete(\n        `projects/${projectUuid}/batch/${batchUuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (e) {\n      return UtilV2.errorResponse(e)\n    }\n  },\n}\n","import UtilV2, { ErrorResponseV2, PaginationResponseV2 } from './util'\n\nexport interface Phoneme {\n  uuid: string\n  alphabet: string\n  word: string\n  phonetic_transcription: string\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface AllPhonemeResponse {\n  success: boolean\n  page: number\n  num_pages: number\n  page_size: number\n  items: Phoneme[]\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize?: number,\n  ): Promise<PaginationResponseV2<AllPhonemeResponse> | ErrorResponseV2> => {\n    try {\n      const response = await UtilV2.get(\n        `phonemes?page=${page}${pageSize ? `&page_size=${pageSize}` : ''}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item: Phoneme) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  create: async (word: string, phonetic_transcription: string) => {\n    try {\n      const response = await UtilV2.post('phonemes', {\n        word,\n        phonetic_transcription,\n      })\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  get: async (phonemeUuid: string) => {\n    try {\n      const response = await UtilV2.get(`phonemes/${phonemeUuid}`)\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  delete: async (phoneme_uuid: string) => {\n    try {\n      const response = await UtilV2.delete(`phonemes/${phoneme_uuid}`)\n      const json = response.json()\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n}\n","import UtilV2, { ErrorResponseV2, PaginationResponseV2 } from './util'\n\nexport interface TermSubstitution {\n  uuid: string\n  original_text: string\n  replacement_text: string\n  created_at: Date\n  updated_at: Date\n}\n\nexport interface AllTermSubstitutionResponse {\n  success: boolean\n  page: number\n  num_pages: number\n  page_size: number\n  items: TermSubstitution[]\n}\n\nexport default {\n  all: async (\n    page: number,\n    pageSize?: number,\n  ): Promise<\n    PaginationResponseV2<AllTermSubstitutionResponse> | ErrorResponseV2\n  > => {\n    try {\n      const response = await UtilV2.get(\n        `term_substitutions?page=${page}${\n          pageSize ? `&page_size=${pageSize}` : ''\n        }`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.items = json.items.map((item: TermSubstitution) => ({\n          ...item,\n          created_at: new Date(item.created_at),\n          updated_at: new Date(item.updated_at),\n        }))\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  create: async (original_text: string, replacement_text: string) => {\n    try {\n      const response = await UtilV2.post('term_substitutions', {\n        original_text,\n        replacement_text,\n      })\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  get: async (termSubstitutionUuid: string) => {\n    try {\n      const response = await UtilV2.get(\n        `term_substitutions/${termSubstitutionUuid}`,\n      )\n      let json = await response.json()\n      if (json.success) {\n        json.item = {\n          ...json.item,\n          created_at: new Date(json.item.created_at),\n          updated_at: new Date(json.item.updated_at),\n        }\n      }\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n  delete: async (termSubstitutionUuid: string) => {\n    try {\n      const response = await UtilV2.delete(\n        `term_substitutions/${termSubstitutionUuid}`,\n      )\n      const json = response.json()\n      return json\n    } catch (error) {\n      return UtilV2.errorResponse(error)\n    }\n  },\n}\n","import { context } from './context'\nimport ProjectsV2 from './v2/projects'\nimport ClipsV2 from './v2/clips'\nimport RecordingsV2 from './v2/recordings'\nimport VoicesV2 from './v2/voices'\nimport BatchV2 from './v2/batch'\nimport PhonemesV2 from './v2/phonemes'\nimport TermSubstitutionsV2 from './v2/termSubstitutions'\n\nexport const Resemble = {\n  setApiKey: context.setApiKey,\n  setBaseUrl: context.setBaseUrl,\n  setSynthesisUrl: context.setSynthesisUrl,\n\n  v2: {\n    projects: {\n      all: ProjectsV2.all,\n      create: ProjectsV2.create,\n      update: ProjectsV2.update,\n      get: ProjectsV2.get,\n      delete: ProjectsV2.destroy,\n    },\n    clips: {\n      all: ClipsV2.all,\n      createSync: ClipsV2.createSync,\n      createAsync: ClipsV2.createAsync,\n      createDirect: ClipsV2.createDirect,\n      updateAsync: ClipsV2.updateAsync,\n      stream: ClipsV2.stream,\n      get: ClipsV2.get,\n      delete: ClipsV2.destroy,\n    },\n    voices: {\n      all: VoicesV2.all,\n      create: VoicesV2.create,\n      update: VoicesV2.update,\n      build: VoicesV2.build,\n      get: VoicesV2.get,\n      delete: VoicesV2.destroy,\n    },\n    recordings: {\n      all: RecordingsV2.all,\n      get: RecordingsV2.get,\n      create: RecordingsV2.create,\n      update: RecordingsV2.update,\n      delete: RecordingsV2.destroy,\n    },\n    batch: {\n      all: BatchV2.all,\n      get: BatchV2.get,\n      create: BatchV2.create,\n      delete: BatchV2.delete,\n    },\n    phonemes: {\n      all: PhonemesV2.all,\n      create: PhonemesV2.create,\n      get: PhonemesV2.get,\n      delete: PhonemesV2.delete,\n    },\n    termSubstitutions: {\n      all: TermSubstitutionsV2.all,\n      get: TermSubstitutionsV2.get,\n      create: TermSubstitutionsV2.create,\n      delete: TermSubstitutionsV2.delete,\n    },\n  },\n}\n"],"names":["apiKey","baseUrl","synthesisServerHeaders","Authorization","context","headers","setBaseUrl","url","endsWith","setApiKey","key","setSynthesisUrl","synthesisServerUrl","endpoint","version","startsWith","substring","ending","synServerUrl","UtilV2","path","useSynthesisServer","fetch","method","data","body","JSON","stringify","e","success","message","arrays","totalLength","length","reduce","accumulator","currentValue","returnValue","Uint8Array","offset","array","set","ProjectsV2","all","page","pageSize","Promise","resolve","_catch","then","response","json","items","map","item","_extends","created_at","Date","updated_at","reject","get","uuid","create","projectInput","update","destroy","StreamDecoder","bufferSize","ignoreWavHeader","timeStampsProcessingRequired","Error","this","chunks","headerBuffer","processTimeStamps","timeStampsBuffer","allTimestampsProcessed","timeStamps","prototype","setBufferSize","size","setIgnoreWavHeader","val","decodeChunk","chunk","push","tempBuf","concatUint8Arrays","slice","tempDataBuffer","obj","extractTimestampsFromBuffer","timestamps","_tempBuf3","_tempDataBuffer2","_tempDataBuffer3","flushBuffer","force","returnBuffer","leftoverBuffer","reset","getTimestamps","buffer","dataView","DataView","byteOffset","byteLength","sampleRate","getUint16","getUint32","chunkType","textDecoder","decode","graph_chars","graph_times","phon_chars","phon_times","_ref2","remSize","nCuePoints","cp","idx","cuePoint","cuePoints","listEndPoint","subChunkSize","nSamples","charType","trim","textLen","text","TextDecoder","mappedType","grph","phon","cueIdx","_ref","projectUuid","clipInput","createAsync","createSync","createDirect","stream","_regeneratorRuntime","mark","streamInput","streamConfig","defaultStreamConfig","getTimeStamps","_response$headers$get","streamDecoder","reader","_yield$_awaitAsyncGen","value","_buffer","buffToReturn","wrap","_context","prev","next","wav_encoded_timestamps","sent","ok","includes","_awaitAsyncGenerator","error","status","getReader","read","done","releaseLock","t1","stop","_callee","updateAsync","RecordingsV2","voiceUuid","recordingInput","fileSizeInBytes","formData","FormData","append","name","emotion","is_active","knownLength","getHeaders","VoicesV2","voiceInput","build","batchInputConfig","options","voice_uuid","sample_rate","output_format","outputFormat","precision","callbackUri","batchUuid","delete","PhonemesV2","word","phonetic_transcription","phonemeUuid","phoneme_uuid","TermSubstitutionsV2","original_text","replacement_text","termSubstitutionUuid","v2","projects","clips","ClipsV2","voices","recordings","batch","BatchV2","phonemes","termSubstitutions"],"mappings":"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"}