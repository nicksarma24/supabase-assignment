/// <reference types="node" />
export declare const Resemble: {
    setApiKey: (key: string) => void;
    setBaseUrl: (url: string) => void;
    setSynthesisUrl: (url: string) => void;
    v2: {
        projects: {
            all: (page: number, pageSize?: number) => Promise<import("./v2/util").PaginationResponseV2<import("./v2/projects").Project> | import("./v2/util").ErrorResponseV2>;
            create: (projectInput: import("./v2/projects").ProjectInput) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").WriteResponseV2<import("./v2/projects").Project>>;
            update: (uuid: string, projectInput: import("./v2/projects").ProjectInput) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").UpdateResponseV2<import("./v2/projects").Project>>;
            get: (uuid: string) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").ReadResponseV2<import("./v2/projects").Project>>;
            delete: (uuid: string) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").DeleteResponseV2>;
        };
        clips: {
            all: (projectUuid: string, page: number, pageSize: number) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").PaginationResponseV2<import("./v2/clips").Clip>>;
            createSync: (projectUuid: string, clipInput: import("./v2/clips").SyncClipInput) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").WriteResponseV2<import("./v2/clips").Clip>>;
            createAsync: (projectUuid: string, clipInput: import("./v2/clips").AsyncClipInput) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").WriteResponseV2<import("./v2/clips").Clip>>;
            createDirect: (clipInput: import("./v2/clips").DirectClipInput) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/clips").DirectClip | import("./v2/clips").DirectClipError>;
            updateAsync: (projectUuid: string, uuid: string, clipInput: import("./v2/clips").AsyncClipInput) => Promise<any>;
            stream: (streamInput: import("./v2/clips").StreamInput, streamConfig?: import("./v2/clips").StreamConfig) => AsyncGenerator<unknown, any, unknown>;
            get: (projectUuid: string, uuid: string) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").ReadResponseV2<import("./v2/clips").Clip>>;
            delete: (projectUuid: string, uuid: string) => Promise<any>;
        };
        voices: {
            all: (page: number, pageSize: number) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").PaginationResponseV2<import("./v2/voices").Voice>>;
            create: (voiceInput: import("./v2/voices").VoiceInput) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").WriteResponseV2<import("./v2/voices").Voice>>;
            update: (uuid: string, voiceInput: import("./v2/voices").VoiceInput) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").UpdateResponseV2<import("./v2/voices").Voice>>;
            build: (uuid: string) => Promise<import("./v2/util").ErrorResponseV2 | {
                success: boolean;
                message?: string;
            }>;
            get: (uuid: string) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").ReadResponseV2<import("./v2/voices").Voice>>;
            delete: (uuid: string) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").DeleteResponseV2>;
        };
        recordings: {
            all: (voiceUuid: string, page: number, pageSize: number) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").PaginationResponseV2<import("./v2/recordings").Recording>>;
            get: (voiceUuid: string, uuid: string) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").ReadResponseV2<import("./v2/recordings").Recording>>;
            create: (voiceUuid: string, recordingInput: import("./v2/recordings").RecordingInput, buffer: Buffer, fileSizeInBytes: number) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").WriteResponseV2<import("./v2/recordings").Recording>>;
            update: (voiceUuid: string, uuid: string, recordingInput: import("./v2/recordings").RecordingInput) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").UpdateResponseV2<import("./v2/recordings").Recording>>;
            delete: (voiceUuid: string, uuid: string) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").DeleteResponseV2>;
        };
        batch: {
            all: (projectUuid: string, page: number, pageSize?: number) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").PaginationResponseV2<import("./v2/batch").Batch>>;
            get: (projectUuid: string, batchUuid: string) => Promise<any>;
            create: (projectUuid: string, voiceUuid: string, body: [string, string][] | string[], batchInputConfig: {
                callbackUri: string;
                precision: "PCM_32" | "PCM_16" | "MULAW";
                sampleRate: 8000 | 16000 | 22050 | 44100;
                outputFormat: "wav" | "mp3";
            }) => Promise<any>;
            delete: (projectUuid: string, batchUuid: string) => Promise<any>;
        };
        phonemes: {
            all: (page: number, pageSize?: number) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").PaginationResponseV2<import("./v2/phonemes").AllPhonemeResponse>>;
            create: (word: string, phonetic_transcription: string) => Promise<any>;
            get: (phonemeUuid: string) => Promise<any>;
            delete: (phoneme_uuid: string) => Promise<any>;
        };
        termSubstitutions: {
            all: (page: number, pageSize?: number) => Promise<import("./v2/util").ErrorResponseV2 | import("./v2/util").PaginationResponseV2<import("./v2/termSubstitutions").AllTermSubstitutionResponse>>;
            get: (termSubstitutionUuid: string) => Promise<any>;
            create: (original_text: string, replacement_text: string) => Promise<any>;
            delete: (termSubstitutionUuid: string) => Promise<any>;
        };
    };
};
